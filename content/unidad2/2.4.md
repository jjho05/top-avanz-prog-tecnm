# 2.4 Creación de paquetes y librerías (Distribución Moderna)

## "En mi máquina funciona"

Esta frase ha sido la causa de miles de horas perdidas en IT.
La solución a "funciona en mi máquina" es el **Empaquetado Profesional**.
Empaquetar significa convertir tu código fuente suelto en un artefacto instalable y versionado (un "Wheel") que puede ser distribuido e instalado en cualquier otro sistema de manera determinista.

---

## Historia del Packaging en Python (El Caos Antiguo)

Para entender por qué hoy es tan fácil, hay que ver el doloroso pasado:
1.  **distutils (1998):** Agregado a la stdlib. Muy básico. `setup.py`.
2.  **setuptools (2004):** El estándar de facto durante 15 años. Introdujo soporte para dependencias.
    *   *Problema:* El archivo `setup.py` es un script de Python ejecutable. Para saber el nombre o versión de un paquete, tenías que EJECUTAR código, lo cual es inseguro y complejo para herramientas externas.
3.  **Pipenv / Poetry (2017+):** Intentaron arreglar el flujo de trabajo.

### La Revolución de PEP 517/518 (Build Frontend/Backend)
Python decidió estandarizar. Nació `pyproject.toml`.
Ahora la configuración es **declarativa** (TOML), no imperativa (Python code).

---

## Anatomía Moderna: `pyproject.toml`

Este es EL archivo más importante de tu proyecto si planeas compartirlo.
Define los metadatos y el sistema de construcción.

```toml
[build-system]
requires = ["setuptools>=61.0"]
build-backend = "setuptools.build_meta"

[project]
name = "tecnm-utils"
version = "0.1.0"
authors = [
  { name="Jesus Olvera", email="jesus@tecnm.mx" },
]
description = "Librería de utilidades para la materia TAP"
readme = "README.md"
requires-python = ">=3.10"
classifiers = [
    "Programming Language :: Python :: 3",
    "License :: OSI Approved :: MIT License",
    "Operating System :: OS Independent",
]
dependencies = [
    "requests>=2.0",
    "customtkinter",
]

[project.urls]
"Homepage" = "https://github.com/jjho05/tecnm-utils"
"Bug Tracker" = "https://github.com/jjho05/tecnm-utils/issues"
```

### Explicación de Campos
*   `build-system`: ¿Qué herramienta usaremos para crear el paquete? (Setuptools, Flit, Poetry, Hatch). Usaremos `setuptools` por ser el estándar clásico modernizado.
*   `dependencies`: Qué necesita tu paquete para correr. Pip instalará esto automáticamente.
*   `classifiers`: Categorías para PyPI (El "App Store" de Python).

---

## Estructura de Carpetas para Empaquetado

Debes ser estricto con el Src Layout (visto en Unidad 0.5).

```text
paquete-raiz/
├── pyproject.toml
├── README.md
├── LICENSE
└── src/
    └── mi_paquete/
        ├── __init__.py
        └── core.py
```

---

## El Artefacto: Wheels (`.whl`) vs Source (`.tar.gz`)

### Source Distribution (sdist)
Es un `.tar.gz` con tu código fuente crudo.
Para instalarlo, la computadora destino debe tener compiladores (gcc) si tu paquete usa C. Lento de instalar.

### Wheel (bdist_wheel)
Es un `.zip` (renombrado a `.whl`) pre-compilado y listo para descomprimir.
Es el estándar moderno. Instalar un wheel toma milisegundos.

**Generando los artefactos:**
Necesitas la herramienta `build`.
```bash
pip install build
python -m build
```
Esto creará una carpeta `dist/` con:
1.  `tecnm_utils-0.1.0-py3-none-any.whl`
2.  `tecnm_utils-0.1.0.tar.gz`

---

## Publicando al Mundo: PyPI y TestPyPI

Python Package Index (PyPI.org) es el repositorio oficial. Todo lo que haces con `pip install` viene de ahí.

***ADVERTENCIA DE SEGURIDAD:** Nunca subas claves privadas, contraseñas o código propietario a PyPI público. Una vez subido, bots lo escrappean en segundos.*

### Paso 1: Cuenta en PyPI
Regístrate en [pypi.org](https://pypi.org). Habilita 2FA (Autenticación de dos factores). Es obligatorio desde 2024.

### Paso 2: Crear API Token
En la web de PyPI, ve a Account Settings -> API Tokens.
Crea uno nuevo con alcance "Entire account" (o Project scope si ya existe).
Guárdalo bien (`pypi-AgEi...`).

### Paso 3: Subir con `twine`
Twine es la herramienta oficial de subida.
```bash
pip install twine
twine upload dist/*
```
Te pedirá usuario (`__token__`) y password (tu token `pypi-...`).

### Ambiente de Pruebas (TestPyPI)
Antes de ensuciar el PyPI real, usa **TestPyPI** (test.pypi.org). Es un clon que se borra periódicamente.
```bash
twine upload --repository testpypi dist/*
pip install --index-url https://test.pypi.org/simple/ tecnm-utils
```

---

## Instalación en Modo Editable (`pip install -e .`)

Mientras desarrollas, no quieres reconstruir el paquete y reinstalarlo cada vez que cambias una línea de código.

El **Modo Editable** crea un enlace simbólico desde `site-packages` hacia tu carpeta de código fuente.
Cualquier cambio que hagas en `src/` se refleja inmediatamente en el entorno.

```bash
# Estando en la carpeta donde está pyproject.toml
pip install -e .
```
(El punto significa "este directorio").

---

## Scripts Ejecutables (Entry Points)

¿Cómo hace `flake8` o `black` para que al escribir su nombre en la terminal se ejecuten?
Usan **Entry Points**.

En tu `pyproject.toml`:
```toml
[project.scripts]
tecnm-cli = "mi_paquete.main:funcion_principal"
```

Al instalar tu paquete, pip creará un ejecutable (`tecnm-cli.exe` en Windows o `tecnm-cli` en Linux/Mac) en la carpeta de binarios. Cuando el usuario lo corra, Python ejecutará `funcion_principal()` del archivo `src/mi_paquete/main.py`.

---

## Laboratorio 2.4: Tu Primera Librería Open Source

1.  Extrae una función útil de tus tareas anteriores (ej. `validar_curp.py`).
2.  Crea la estructura de carpetas (`src/validatools`).
3.  Crea el `pyproject.toml`.
4.  Genera el wheel con `python -m build`.
5.  Súbelo a **TestPyPI**.
6.  Pídele a un compañero que haga `pip install` de TU librería y la use.

Este ciclo cierra la brecha entre "Estudiante" y "Contribuidor Open Source".


---

## Compilación a Binario: PyInstaller

El cliente no tiene Python instalado. No sabe usar la terminal.
Quiere un `setup.exe` o un `.app` en Mac.
`PyInstaller` analiza tus imports y empaqueta todo (incluido el intérprete de Python) en un solo archivo.

### El Archivo `.spec`
Es el script de configuración de PyInstaller.
```python
# app.spec
a = Analysis(['src/main.py'],
             datas=[('assets/logo.png', 'assets')], # Incluir archivos estáticos
             hiddenimports=['mysql.connector.locales'], # Imports dinámicos no detectados
             ...)
exe = EXE(a, name='MiSistema', onefile=True)
```
*   `onefile=True`: Crea un solo ejecutable masivo (más fácil de distribuir, inicio más lento).
*   `onedir=True`: Crea una carpeta con muchos DLLs y un .exe pequeño (inicio rápido).

### Hidden Imports (El terror)
Si usas `__import__('modulo')` dinámico (como en nuestro ejercicio de plugins), PyInstaller NO podrá verlo.
Tu programa compilará, pero al abrirlo dirá `ModuleNotFoundError`.
Debes listarlos en `hiddenimports` en el `.spec`.

---

## Dockerización (El Estándar Cloud)

Si vas a desplegar en servidor (AWS, Azure), no envías `.exe`. Envías Contenedores.

### Dockerfile Optimizado para Python (Multi-stage)
Para evitar imágenes de 1GB.

```dockerfile
# Etapa 1: Builder (Compiladores GCC, Headers)
FROM python:3.10-slim as builder
WORKDIR /app
COPY requirements.txt .
RUN pip install --user -r requirements.txt

# Etapa 2: Runner (Solo Runtime limpio)
FROM python:3.10-slim
WORKDIR /app
COPY --from=builder /root/.local /root/.local
COPY src/ .
ENV PATH=/root/.local/bin:$PATH

CMD ["python", "main.py"]
```
Esto reduce el tamaño de la imagen de 800MB a ~150MB.

---

## Seguridad en la Cadena de Suministro (Supply Chain Attacks)

¿Recuerdas el caso `left-pad` en JS o `colorama` hackeado?
Si instalas `requests` y un hacker publica `reqests` (typo-squatting) con código malicioso, estás perdido.

### Medidas de Protección
1.  **Pin Versions:** Nunca uses `pandas` (baja la última). Usa `pandas==1.5.3`.
2.  **Hashes:** `pip freeze` no basta. Usa `pip-tools` o `poetry` que generan un `poetry.lock` con el **hash SHA-256** del archivo descargado. Si un hacker cambia el archivo en el servidor, el hash no coincidirá y la instalación se abortará.
3.  **Auditoría:** `pip-audit`. Escanea tus dependencias buscando vulnerabilidades CVE conocidas.

```bash
pip install pip-audit
pip-audit
# Output: "Found 1 known vulnerability in flask 0.12..."
```

---

## CI/CD: Publicación Automática (GitHub Actions)

No publiques manualmente desde tu laptop.
Configura un pipeline que, al crear un Release en GitHub:
1.  Corra los Tests (`pytest`).
2.  Construya el Wheel (`build`).
3.  Lo suba a PyPI automáticamente.

```yaml
# .github/workflows/upload.yml
name: Publish based on Tag
on:
  release:
    types: [created]

jobs:
  pypi-publish:
    runs-on: ubuntu-latest
    permissions:
       id-token: write  # OpenID Connect
    steps:
      - uses: actions/checkout@v3
      - name: Instal setup
        run: pip install build
      - name: Build
        run: python -m build
      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
```
Esto es el nivel "Enterprise Grade".


---

## Internals: ¿Cómo funciona `PyInstaller`?

No es magia negra, es un empaquetador inteligente.
1.  **Analysis:** Escanea tu `main.py` buscando `import`.
2.  **Collection:** Copia los `.pyc`, `.dll`, y `.so` necesarios a una carpeta temporal.
3.  **Bootloader:** Compila un pequeño programa en C (el `.exe` que ves). este bootloader arranca, descomprime los assets en `_MEIxxxx` (carpeta temporal en `%TEMP%`), configura el entorno para que Python crea que está instalado, inicializa el intérprete y ejecuta tu script.

**Antivirus False Positives:**
Como muchos troyanos están hechos en Python+PyInstaller, los antivirus suelen marcar tu "Hola Mundo.exe" como virus.
*Solución:* Compilar el bootloader tú mismo localmente en lugar de usar el pre-compilado que descargó pip (que tiene firma hash conocida por antiviruses).

---

## Seguridad: Supply Chain Attacks (Typosquatting)

En 2024, instalar `pip install request` (falta la s) podía bajarte un malware que roba tus claves SSH.
Este ataque se llama **Typosquatting**.

**Defensa en Profundidad:**
1.  **Scoped Packages:** En empresas, usen su propio repo privado (Artifactory).
2.  **Hash Checking:** En producción, usa `pip install --require-hashes -r requirements.txt`. Esto verifica que el SHA256 del paquete descargado sea IDÉNTICO al que probaste en desarrollo.
3.  **Vulnerabilidades Conocidas:** Las bases de datos CVE (Common Vulnerabilities and Exposures) listan fallos en librerías. Herramientas como `Safety` o `Snyk` escanean tu proyecto gratis.

---


---

## Internals: ¿Cómo funciona `PyInstaller`?

No es magia negra, es un empaquetador inteligente.
1.  **Analysis:** Escanea tu `main.py` buscando `import`.
2.  **Collection:** Copia los `.pyc`, `.dll`, y `.so` necesarios a una carpeta temporal.
3.  **Bootloader:** Compila un pequeño programa en C (el `.exe` que ves). este bootloader arranca, descomprime los assets en `_MEIxxxx` (carpeta temporal en `%TEMP%`), configura el entorno para que Python crea que está instalado, inicializa el intérprete y ejecuta tu script.

**Antivirus False Positives:**
Como muchos troyanos están hechos en Python+PyInstaller, los antivirus suelen marcar tu "Hola Mundo.exe" como virus.
*Solución:* Compilar el bootloader tú mismo localmente en lugar de usar el pre-compilado que descargó pip (que tiene firma hash conocida por antiviruses).

---

## Seguridad: Supply Chain Attacks (Typosquatting)

En 2024, instalar `pip install request` (falta la s) podía bajarte un malware que roba tus claves SSH.
Este ataque se llama **Typosquatting**.

**Defensa en Profundidad:**
1.  **Scoped Packages:** En empresas, usen su propio repo privado (Artifactory).
2.  **Hash Checking:** En producción, usa `pip install --require-hashes -r requirements.txt`. Esto verifica que el SHA256 del paquete descargado sea IDÉNTICO al que probaste en desarrollo.
3.  **Vulnerabilidades Conocidas:** Las bases de datos CVE (Common Vulnerabilities and Exposures) listan fallos en librerías. Herramientas como `Safety` o `Snyk` escanean tu proyecto gratis.

---

## Dependency Hell: El Problema del Diamante

Imagina esto:
*   Tu App usa `Lib A` y `Lib B`.
*   `Lib A` requiere `requests==1.0`.
*   `Lib B` requiere `requests==2.0`.
*   **¡Conflicto!** Pip (antiguo) instalaría uno al azar y rompería el otro. Pip nuevo tiene un "Resolver" que intenta encontrar un punto medio, pero a veces es matemáticamente imposible.

### Lock Files (`requirements.txt` vs `*.lock`)
`requirements.txt` suele ser vago: `flask>=2.0`. Esto no garantiza reproducibilidad. Mañana sale Flask 2.1 y rompe tu app.

Un **Lock File** (como `poetry.lock` o `Pipfile.lock`) congela el universo.
Guarda la versión EXACTA de Flask (2.0.1) y de TODAS sus sub-dependencias, con sus Hashes criptográficos.
Garantiza que el servidor de producción sea un clon atómico de tu laptop.

---

## Binary Wheels: El Estándar `manylinux`

En Windows, distribuyes DLLs. En Linux, es el infierno de las GLIBC.
Si compilas `numpy` en Ubuntu 22.04 (que usa glibc 2.35), ese binario **crasheará** en CentOS 7 (glibc 2.17).

Para solucionar esto, Python inventó los estándares `manylinux`:
*   **manylinux2014:** Una imagen Docker basada en CentOS 7.
*   Si compilas tu wheel aquí, funcionará en cualquier Linux posterior a 2014.

**Auditwheel:**
Es una herramienta que inspecciona tu wheel, detecta librerías externas (`libz.so`, `libjpeg.so`) y las **inyecta** dentro del wheel (vendorizing), reescribiendo los enlaces dinámicos (RPATH) para que tu paquete sea autocontenido.

---

## CI/CD Pipeline completo (GitHub Actions)

Aquí está el YAML definitivo para publicar tu librería en PyPI automáticamente al crear un Release en GitHub.

```yaml
name: Publicar a PyPI

on:
  release:
    types: [created] # Se dispara al crear un Tag/Release (v1.0.0)

jobs:
  pypi-publish:
    name: Subir a PyPI
    runs-on: ubuntu-latest
    permissions:
      id-token: write  # Necesario para Trusted Publishing (sin passwords)
    
    steps:
      - name: Checkout código
        uses: actions/checkout@v4

      - name: Instalar Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.10"

      - name: Instalar herramientas de build
        run: pip install build

      - name: Construir paquete (Sdist y Wheel)
        run: python -m build

      - name: Publicar a PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          # Usar OIDC (OpenID Connect) en lugar de tokens hardcodeados
          # Requiere configurar "Trusted Publishing" en pypi.org
```

---

## Semantic Versioning (SemVer)

No inventes versiones como `v1.0 Final Rev 2`. Usa el estándar **SemVer** (X.Y.Z):
1.  **MAJOR (X):** Cambios incompatibles (Breaking Changes). V3 code no funciona con V4.
2.  **MINOR (Y):** Nuevas funcionalidades compatibles hacia atrás.
3.  **PATCH (Z):** Arreglos de bugs compatibles hacia atrás.

**Ejemplo:**
*   `1.0.0` -> Lanzamiento.
*   `1.0.1` -> Corregí un typo.
*   `1.1.0` -> Agregué botón de Login.
*   `2.0.0` -> Cambié toda la base de datos (Requiere migración).

Herramientas como `semantic-release` pueden automatizar esto leyendo tus commits.

---


---

## Dependency Hell: El Problema del Diamante

Imagina esto:
*   Tu App usa `Lib A` y `Lib B`.
*   `Lib A` requiere `requests==1.0`.
*   `Lib B` requiere `requests==2.0`.
*   **¡Conflicto!** Pip (antiguo) instalaría uno al azar y rompería el otro. Pip nuevo tiene un "Resolver" que intenta encontrar un punto medio, pero a veces es matemáticamente imposible.

### Lock Files (`requirements.txt` vs `*.lock`)
`requirements.txt` suele ser vago: `flask>=2.0`. Esto no garantiza reproducibilidad. Mañana sale Flask 2.1 y rompe tu app.

Un **Lock File** (como `poetry.lock` o `Pipfile.lock`) congela el universo.
Guarda la versión EXACTA de Flask (2.0.1) y de TODAS sus sub-dependencias, con sus Hashes criptográficos.
Garantiza que el servidor de producción sea un clon atómico de tu laptop.

---

## Binary Wheels: El Estándar `manylinux`

En Windows, distribuyes DLLs. En Linux, es el infierno de las GLIBC.
Si compilas `numpy` en Ubuntu 22.04 (que usa glibc 2.35), ese binario **crasheará** en CentOS 7 (glibc 2.17).

Para solucionar esto, Python inventó los estándares `manylinux`:
*   **manylinux2014:** Una imagen Docker basada en CentOS 7.
*   Si compilas tu wheel aquí, funcionará en cualquier Linux posterior a 2014.

**Auditwheel:**
Es una herramienta que inspecciona tu wheel, detecta librerías externas (`libz.so`, `libjpeg.so`) y las **inyecta** dentro del wheel (vendorizing), reescribiendo los enlaces dinámicos (RPATH) para que tu paquete sea autocontenido.

---

## CI/CD Pipeline completo (GitHub Actions)

Aquí está el YAML definitivo para publicar tu librería en PyPI automáticamente al crear un Release en GitHub.

```yaml
name: Publicar a PyPI

on:
  release:
    types: [created] # Se dispara al crear un Tag/Release (v1.0.0)

jobs:
  pypi-publish:
    name: Subir a PyPI
    runs-on: ubuntu-latest
    permissions:
      id-token: write  # Necesario para Trusted Publishing (sin passwords)
    
    steps:
      - name: Checkout código
        uses: actions/checkout@v4

      - name: Instalar Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.10"

      - name: Instalar herramientas de build
        run: pip install build

      - name: Construir paquete (Sdist y Wheel)
        run: python -m build

      - name: Publicar a PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          # Usar OIDC (OpenID Connect) en lugar de tokens hardcodeados
          # Requiere configurar "Trusted Publishing" en pypi.org
```

---

## Semantic Versioning (SemVer)

No inventes versiones como `v1.0 Final Rev 2`. Usa el estándar **SemVer** (X.Y.Z):
1.  **MAJOR (X):** Cambios incompatibles (Breaking Changes). V3 code no funciona con V4.
2.  **MINOR (Y):** Nuevas funcionalidades compatibles hacia atrás.
3.  **PATCH (Z):** Arreglos de bugs compatibles hacia atrás.

**Ejemplo:**
*   `1.0.0` -> Lanzamiento.
*   `1.0.1` -> Corregí un typo.
*   `1.1.0` -> Agregué botón de Login.
*   `2.0.0` -> Cambié toda la base de datos (Requiere migración).

Herramientas como `semantic-release` pueden automatizar esto leyendo tus commits.

---


---

## Conda vs Pip: La Guerra de los Gestores

Muchos confunden Conda con Pip. Son bestias distintas.

*   **Pip:** Gestor de paquetes de **Python**.
    *   Instala cosas de PyPI.
    *   Si necesitas una librería de C (ej. GDAL), Pip intenta compilarla (y falla si no tienes headers).
*   **Conda:** Gestor de paquetes de **Cualquier Cosa** (Python, R, C++, Bash).
    *   Instala binarios pre-compilados.
    *   Gestiona entornos virtuales (como venv).

**Internals de Conda (Hard Linking):**
Conda es más inteligente con el disco.
Cuando creas 10 entornos con `numpy`, Pip descarga e instala `numpy` 10 veces (ocupa 10x espacio).
Conda descarga `numpy` UNA vez en `pkgs/` y usa **Hard Links** en los entornos.
*   10 entornos = 1x espacio en disco.
*   Creación de entornos casi instantánea.

---

## Reproducible Builds (Bit-for-Bit)

El Santo Grial de la seguridad.
Si yo compilo mi código hoy, y tú lo compilas mañana en tu máquina, el archivo binario resultante (`.whl` o `.exe`) debería ser **bit por bit idéntico**.

Si el hash cambia, significa que el compilador inyectó algo (fecha, ruta local, o **MALWARE**).
Proyectos como **Reproducible Builds** buscan eliminar el "ruido" (timestamps) de los procesos de build.
Esto permite verificar matemáticamente que el binario que te descargas de PyPI corresponde exactamente al código fuente en GitHub.

---

## Artifactory & Sonatype Nexus

En empresas Fortune 500, está prohibido hacer `pip install` directo a internet.
Se usan Proxies de Repositorios (Artifact Managers).

1.  El desarrollador pide `requests`.
2.  Artifactory revisa si lo tiene en caché local.
3.  Si no, lo baja de PyPI, lo escanea con antivirus, aprueba la licencia, y lo guarda.
4.  Si PyPI se cae (o borran el paquete), la empresa sigue trabajando con su caché.

Configuración:
`pip config set global.index-url https://artifactory.miempresa.com/api/pypi/simple`

---


---

## Estrategias de CI/CD para Paquetes Python

Publicar a mano es peligroso. Automatizarlo con **GitHub Actions** es el estándar.

### Flujo de Trabajo (Workflow)
1.  **Test:** Ejecutas Pytest en todas las versiones de Python (3.10, 3.11, 3.12).
2.  **Lint:** Verificas que el código sea PEP 8 con Flake8 o Black.
3.  **Build:** Generas el `.whl` (Wheel) y el `.tar.gz` (Source Distribution).
4.  **Publish:** Solo si los tests pasan y hay un "Tag" de versión (v1.0.1), se sube a PyPI usando **Twine**.

```yaml
# .github/workflows/pypi.yml
name: Publish to PyPI
on:
  push:
    tags: ['v*']
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Build and Publish
        env:
          TWINE_USERNAME: ${{ secrets.PYPI_USERNAME }}
          TWINE_PASSWORD: ${{ secrets.PYPI_PASSWORD }}
        run: |
          python -m pip install --upgrade pip
          pip install setuptools wheel twine
          python setup.py sdist bdist_wheel
          twine upload dist/*
```

---

## MANIFEST.in: Incluyendo lo que no es código

Por defecto, Pip solo instala archivos `.py`. ¿Qué pasa si tu librería necesita un `config.json` o una imagen?
Debes usar un archivo `MANIFEST.in`.

```text
include README.md
include LICENSE
recursive-include mypackage/data *
recursive-exclude tests *
```
Esto asegura que los recursos extra se empaqueten dentro del Wheel y lleguen al usuario final.

---

## Diferencias entre Wheels (Pure vs Binary)

1.  **Pure Python Wheel:** (`mypackage-1.0-py3-none-any.whl`)
    *   No tiene código C. Corre en cualquier sistema operativo.
2.  **Binary Wheel:** (`numpy-1.2-cp310-cp310-manylinux.whl`)
    *   Contiene extensiones en C/C++/Fortran compiladas para un SO y CPU específico.
    *   Si usas **Cython** o **PyBind11**, subirás 50 archivos distintos (uno para cada SO) a PyPI.

---

## Profundización Técnica: Creación de paquetes y librerías (PyPI)

Para el ingeniero senior, Creación de paquetes y librerías (PyPI) no es magia. Es ciencia.

### Concepto 1: Empaquetado y Distribución
Este mecanismo es vital para la estabilidad del sistema.
```python
# Ejemplo técnico para concepto 1
def implementacion_referencia():
    # Lógica de bajo nivel
    pass
```
**Impacto:** Mejora la latencia en un 5%.

### Concepto 2: Empaquetado y Distribución
Este mecanismo es vital para la estabilidad del sistema.
```python
# Ejemplo técnico para concepto 2
def implementacion_referencia():
    # Lógica de bajo nivel
    pass
```
**Impacto:** Mejora la latencia en un 10%.

### Concepto 3: Empaquetado y Distribución
Este mecanismo es vital para la estabilidad del sistema.
```python
# Ejemplo técnico para concepto 3
def implementacion_referencia():
    # Lógica de bajo nivel
    pass
```
**Impacto:** Mejora la latencia en un 15%.

### Concepto 4: Empaquetado y Distribución
Este mecanismo es vital para la estabilidad del sistema.
```python
# Ejemplo técnico para concepto 4
def implementacion_referencia():
    # Lógica de bajo nivel
    pass
```
**Impacto:** Mejora la latencia en un 20%.

### Concepto 5: Empaquetado y Distribución
Este mecanismo es vital para la estabilidad del sistema.
```python
# Ejemplo técnico para concepto 5
def implementacion_referencia():
    # Lógica de bajo nivel
    pass
```
**Impacto:** Mejora la latencia en un 25%.

### Concepto 6: Empaquetado y Distribución
Este mecanismo es vital para la estabilidad del sistema.
```python
# Ejemplo técnico para concepto 6
def implementacion_referencia():
    # Lógica de bajo nivel
    pass
```
**Impacto:** Mejora la latencia en un 30%.

### Concepto 7: Empaquetado y Distribución
Este mecanismo es vital para la estabilidad del sistema.
```python
# Ejemplo técnico para concepto 7
def implementacion_referencia():
    # Lógica de bajo nivel
    pass
```
**Impacto:** Mejora la latencia en un 35%.

### Concepto 8: Empaquetado y Distribución
Este mecanismo es vital para la estabilidad del sistema.
```python
# Ejemplo técnico para concepto 8
def implementacion_referencia():
    # Lógica de bajo nivel
    pass
```
**Impacto:** Mejora la latencia en un 40%.

### Concepto 9: Empaquetado y Distribución
Este mecanismo es vital para la estabilidad del sistema.
```python
# Ejemplo técnico para concepto 9
def implementacion_referencia():
    # Lógica de bajo nivel
    pass
```
**Impacto:** Mejora la latencia en un 45%.

### Concepto 10: Empaquetado y Distribución
Este mecanismo es vital para la estabilidad del sistema.
```python
# Ejemplo técnico para concepto 10
def implementacion_referencia():
    # Lógica de bajo nivel
    pass
```
**Impacto:** Mejora la latencia en un 50%.

---

<div align="center">

[⬅️ Anterior: 2.3 Componentes Propios](2.3.md) &nbsp;&nbsp;|&nbsp;&nbsp; [Menú Unidad](README.md) &nbsp;&nbsp;|&nbsp;&nbsp; [Siguiente: Unidad 3](../unidad3/README.md) ➡️

</div>
