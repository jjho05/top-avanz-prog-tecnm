# 2.3 Creaci칩n de componentes (visuales y no visuales) definidos por el usuario

## De Consumidor a Creador

Hasta ahora hemos usado componentes de otros (`ctk.CTkButton`, `list`, `logging`).
El salto a "Desarrollador Senior" ocurre cuando dejas de copiar c칩digo y empiezas a **encapsular** tu propio c칩digo en componentes reutilizables.

En el contexto de GUIs y Arquitectura, un componente propio es una Clase que:
1.  **Oculta complejidad:** Tiene una interfaz simple p칰blica.
2.  **Es autocontenida:** Maneja su propio estado interno.
3.  **Es componible:** Puede usarse como ladrillo para construir algo m치s grande.

---

## Herencia vs Composici칩n (The Golden Rule)

Hay dos formas de extender funcionalidad en OOP.

### Herencia ("Es un...")
Creas una clase nueva que hereda de una existente.
*   *Ejemplo:* `class MiBotonRojo(ctk.CTkButton):`
*   *Cu치ndo usar:* Cuando quieres modificar el comportamiento fundamental de un widget existente (ej. un Entry que solo acepta n칰meros).

### Composici칩n ("Tiene un...")
Creas una clase nueva (generalmente un `Frame`) que contiene varios widgets dentro.
*   *Ejemplo:* `class TarjetaUsuario(ctk.CTkFrame):` (Tiene un Label nombre, un Label foto y un Bot칩n editar).
*   *Cu치ndo usar:* El 90% de las veces. Es m치s flexible.

**Mantra:** "Prefiere composici칩n sobre herencia".

---

## Creando Widgets Visuales Personalizados

Vamos a crear un componente reutilizable: un `SearchBox` que incluye el icono de lupa, el campo de texto y el bot칩n de limpiar "X".

### Paso 1: Definir la Clase
Heredamos de `CTkFrame` porque nuestro componente ser치 una caja que contiene otros widgets.

```python
import customtkinter as ctk

class SearchBox(ctk.CTkFrame):
    def __init__(self, master, command=None, placeholder="Buscar...", **kwargs):
        super().__init__(master, **kwargs)
        
        self.command = command # Callback al buscar
        
        # Dise침o interno
        self.entry = ctk.CTkEntry(self, placeholder_text=placeholder)
        self.entry.pack(side="left", fill="x", expand=True, padx=5, pady=5)
        
        self.btn = ctk.CTkButton(self, text="游댌", width=30, command=self._on_search)
        self.btn.pack(side="right", padx=5)

        # Binding Enter key
        self.entry.bind("<Return>", lambda e: self._on_search())

    def _on_search(self):
        text = self.entry.get()
        if self.command:
            self.command(text)
            
    def get_text(self):
        # Exponemos un m칠todo p칰blico limpio
        return self.entry.get()
```

### Paso 2: Uso del Componente
Ahora, en tu ventana principal, el c칩digo es limpisimo:

```python
class App(ctk.CTk):
    def __init__(self):
        # ...setup...
        
        # En vez de escribir 10 lineas de Entries y Botones:
        self.search = SearchBox(self, command=self.buscar_bd)
        self.search.pack(fill="x")
        
    def buscar_bd(self, query):
        print(f"Buscando: {query}")
```

Hemos reducido la complejidad cognitiva de la `App` principal.

---

## Clases Mixins (Herencia M칰ltiple)

Python soporta herencia m칰ltiple. Un patr칩n poderoso es el **Mixin**.
Un Mixin es una clase que ofrece funcionalidad extra pero no est치 dise침ada para instanciarse sola.

### Ejemplo: TooltipMixin
Queremos que CUALQUIER widget pueda tener un tooltip (texto de ayuda al pasar el mouse).

```python
class ToolTipMixin:
    def add_tooltip(self, text):
        self.tooltip_text = text
        self.bind("<Enter>", self._show_tooltip)
        self.bind("<Leave>", self._hide_tooltip)
        
    def _show_tooltip(self, event):
        # L칩gica para crear una ventanita flotante (Toplevel)
        pass
        
    def _hide_tooltip(self, event):
        # Destruir ventanita
        pass

# Crear un Bot칩n con superpoderes
class SuperButton(ctk.CTkButton, ToolTipMixin):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

btn = SuperButton(root, text="Info")
btn.add_tooltip("Este bot칩n borra todo el disco duro")
```

---

## Componentes No-Visuales (L칩gica de Negocio)

No todo son botones. Necesitas encapsular la l칩gica.
El patr칩n **Singleton** es controvertido pero 칰til para gestores de configuraci칩n o base de datos.

### El Patr칩n Singleton (Estricto en Python)
Garantiza que solo exista UNA instancia de la clase.

```python
class DatabaseManager:
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super(DatabaseManager, cls).__new__(cls)
            # Inicializaci칩n 칰nica
            cls._instance.connection = None
        return cls._instance

    def connect(self):
        if not self.connection:
            print("Conectando...")
            self.connection = "Conectado"
```
Cualquier parte del c칩digo que haga `DatabaseManager()` recibir치 el MISMO objeto.

---

## Optimization: `__slots__`

Por defecto, las clases en Python usan un diccionario interno `__dict__` para guardar atributos. Esto permite agregar atributos din치micamente (`obj.nuevo = 1`), pero consume mucha RAM.

Si vas a crear **millones** de objetos (ej. Puntos en un gr치fico 3D, Part칤culas, Filas de Excel), usa `__slots__`.

```python
class Punto3D:
    __slots__ = ['x', 'y', 'z'] # Fija la estructura en memoria (tipo C struct)
    
    def __init__(self, x, y, z):
        self.x = x
        self.y = y
        self.z = z

# Ventaja: Ocupa 60% menos RAM.
# Desventaja: No puedes hacer p.color = "red" despu칠s.
```

---

## Propiedades y Encapsulamiento (`@property`)

En Java usas `getEdad()` y `setEdad(x)`. Es feo.
En Python, usas atributos p칰blicos, pero si necesitas l칩gica de validaci칩n, los conviertes en **Propiedades**.

```python
class Usuario:
    def __init__(self, nombre, edad):
        self.nombre = nombre
        self._edad = edad # _ indica protegido (convenci칩n)

    @property
    def edad(self):
        return self._edad

    @edad.setter
    def edad(self, valor):
        if valor < 0:
            raise ValueError("La edad no puede ser negativa")
        self._edad = valor

u = Usuario("Ana", 25)
u.edad = 30 # Llama al setter autom치ticamente
# u.edad = -5 # Lanza error
```
Esto mantiene la sintaxis limpia (`u.edad`) pero con la seguridad de m칠todos privados.

---

## Protocolos y Clases Abstractas (ABC)

Para definir "contratos" que otros componentes deben cumplir.

```python
from abc import ABC, abstractmethod

class Exportador(ABC):
    @abstractmethod
    def exportar(self, datos):
        pass

class ExportarPDF(Exportador):
    def exportar(self, datos):
        print("Generando PDF...")

class ExportarCSV(Exportador):
    def exportar(self, datos):
        print("Guardando CSV...")

# Esto fuerza a que las subclases implementen 'exportar'.
# Si no lo hacen, Python lanza error al instanciar.
```

---

## Laboratorio 2.3: Librer칤a de Componentes UI

Objetivo: Crear un archivo `ui_kit.py` que contenga widgets estandarizados para tu empresa ficticia.

1.  `EmpresaCard`: Un Frame con borde azul, sombra y t칤tulo.
2.  `EmpresaButton`: Un bot칩n que siempre es verde, y al hacer hover se vuelve verde claro.
3.  `EmpresaEntry`: Un Entry que valida que solo sean n칰meros (si `mode="numeric"`).

Luego, un archivo `main.py` que importe estos componentes y arme una interfaz en 10 l칤neas.

Esto simula el trabajo de un Arquitecto de Software que crea herramientas para que los desarrolladores Junior las usen.


---

## Protocolo Descriptor (La Magia Detr치s de `@property`)

쮺칩mo funciona `__get__`, `__set__` y `__delete__`?
Esto es conocimiento arcano de Python.
Si quieres crear un ORM (como Django Models o SQLAlchemy), necesitas esto.

### El Problema de la Repetici칩n
Imagina que tienes 10 atributos que deben ser positivos. Escribir 10 propiedades con `@edad.setter` es aburrido.

### La Soluci칩n: Descriptor
Una clase que controla el acceso a un atributo de OTRA clase.

```python
class EnteroPositivo:
    def __init__(self, nombre_atributo):
        self.nombre = nombre_atributo
        self.attr_interno = f"_{nombre_atributo}"

    def __get__(self, instance, owner):
        if instance is None: return self # Acceso desde la clase
        return getattr(instance, self.attr_interno, 0)

    def __set__(self, instance, value):
        if not isinstance(value, int) or value < 0:
            raise ValueError(f"{self.nombre} debe ser entero positivo")
        setattr(instance, self.attr_interno, value)

class Jugador:
    nivel = EnteroPositivo("nivel")
    vida = EnteroPositivo("vida")
    score = EnteroPositivo("score")

j = Jugador()
j.nivel = 5 # OK
# j.vida = -10 # Error autom치tico
```
Escribimos la l칩gica de validaci칩n UNA VEZ y la reutilizamos N veces.

---

## Patr칩n Registry (Auto-registro)

Supongamos que creas un sistema de plugins. Quieres que al definir una clase, se registre sola en una lista central.
Usamos `__init_subclass__` (el sucesor moderno de las metaclases para este caso).

```python
class WidgetBase:
    _catalogo = {}
    
    def __init_subclass__(cls, tipo=None, **kwargs):
        super().__init_subclass__(**kwargs)
        if tipo:
            WidgetBase._catalogo[tipo] = cls

class BotonRojo(WidgetBase, tipo="boton_danger"):
    pass

class BotonAzul(WidgetBase, tipo="boton_info"):
    pass

# Magia:
print(WidgetBase._catalogo) 
# {'boton_danger': <class 'BotonRojo'>, 'boton_info': <class 'BotonAzul'>}
```
Esto elimina la necesidad de escribir listas gigantes de `if tipo == 'boton': return Boton()`.

---

## Structural Pattern Matching (Python 3.10+)

En componentes complejos, el `if-elif-else` se vuelve inmanejable.
El `match-case` no es solo un switch. Puede desestructurar objetos.

```python
def manejar_evento(evento):
    match evento:
        case {"type": "click", "x": x, "y": y} if x > 100:
            print(f"Click zona derecha: {y}")
        case ["keypress", tecla]:
            print(f"Tecla presionada: {tecla}")
        case Usuario(admin=True, nombre=n):
            print(f"Admin detectado: {n}")
        case _:
            print("Evento desconocido")
```
Esto simplifica dr치sticamente el manejo de mensajes en sistemas distribuidos o GUIs.

---


---

## Duck Typing vs Protocolos Est치ticos

En la secci칩n 8 hablamos de ABCs. Pero el Python moderno prefiere **Protocolos** (`typing.Protocol`).
Es "Duck Typing Checkeable est치ticamente".

```python
from typing import Protocol

class Volador(Protocol):
    def volar(self) -> None:
        ...

def despegar(ave: Volador):
    ave.volar()
    
class Pato:
    def volar(self): print("Cuack, vuelo") # No hereda de Volador, pero CUMPLE la interfaz

despegar(Pato()) # El IDE y Mypy lo marcan como correcto.
```
Esto permite polimorfismo estructural sin la rigidez de la herencia.

---

## Internals: `__slots__` y la memoria

Normalmente `class A: pass` usa un `dict` para atributos.
*   `dict` overhead: ~240 bytes m칤nimo (Hash table dispersa).
*   Si creas 1 mill칩n de objetos, son 240MB de RAM solo en overhead.

**`__slots__` al rescate:**
Le dice a Python: "Esta clase SOLO tendr치 los atributos 'x' e 'y'. No uses diccionario".
Python reserva memoria contigua estilo C-struct.
*   Overhead: ~16 bytes.
*   Diferencia: 15 veces menos RAM.
*   Desventaja: No puedes a침adir atributos nuevos din치micamente (`obj.nuevo = 1` falla).

---


---

## Duck Typing vs Protocolos Est치ticos

En la secci칩n 8 hablamos de ABCs. Pero el Python moderno prefiere **Protocolos** (`typing.Protocol`).
Es "Duck Typing Checkeable est치ticamente".

```python
from typing import Protocol

class Volador(Protocol):
    def volar(self) -> None:
        ...

def despegar(ave: Volador):
    ave.volar()
    
class Pato:
    def volar(self): print("Cuack, vuelo") # No hereda de Volador, pero CUMPLE la interfaz

despegar(Pato()) # El IDE y Mypy lo marcan como correcto.
```
Esto permite polimorfismo estructural sin la rigidez de la herencia.

---

## Internals: `__slots__` y la memoria

Normalmente `class A: pass` usa un `dict` para atributos.
*   `dict` overhead: ~240 bytes m칤nimo (Hash table dispersa).
*   Si creas 1 mill칩n de objetos, son 240MB de RAM solo en overhead.

**`__slots__` al rescate:**
Le dice a Python: "Esta clase SOLO tendr치 los atributos 'x' e 'y'. No uses diccionario".
Python reserva memoria contigua estilo C-struct.
*   Overhead: ~16 bytes.
*   Diferencia: 15 veces menos RAM.
*   Desventaja: No puedes a침adir atributos nuevos din치micamente (`obj.nuevo = 1` falla).

---

## Caso de Estudio Real: Creando un Mini-ORM con Metaclases

Para entender la potencia de las metaclases, vamos a recrear el comportamiento m치gico de Django/SQLAlchemy.
Queremos que al definir una clase, SQL se genere solo.

```python
class Campo:
    def __init__(self, tipo): self.tipo = tipo

class ModelMeta(type):
    def __new__(cls, name, bases, dct):
        # 1. Interceptar definici칩n de la clase
        tabla_name = name.lower()
        campos_sql = []
        
        for key, value in dct.items():
            if isinstance(value, Campo):
                campos_sql.append(f"{key} {value.tipo}")
        
        # 2. Generar SQL de creaci칩n
        dct['_create_sql'] = f"CREATE TABLE {tabla_name} ({', '.join(campos_sql)});"
        
        return super().__new__(cls, name, bases, dct)

class Modelo(metaclass=ModelMeta):
    pass

# --- Uso del Usuario ---
class Usuario(Modelo):
    id = Campo("INTEGER PRIMARY KEY")
    nombre = Campo("TEXT")
    email = Campo("VARCHAR(100)")

# 춰Magia! La SQL se gener칩 sola al definir la clase.
print(Usuario._create_sql)
# CREATE TABLE usuario (id INTEGER PRIMARY KEY, nombre TEXT, email VARCHAR(100));
```
As칤 funcionan los ORMs modernos. La metaclase lee los atributos de clase y configura la "magia" antes de que siquiera instancies un objeto.

---

## Arquitectura de Plugins (Auto-Discovery)

Imagina un sistema como Photoshop. Quieres que otros desarrolladores creen filtros sin tocar tu c칩digo fuente.

**Estructura de Carpetas:**
```text
mi_app/
    core.py
    plugins/
        filtro_byn.py
        filtro_sepia.py
```

**C칩digo del Loader (`core.py`):**
```python
import importlib
import pkgutil
import mi_app.plugins

def cargar_plugins():
    plugins_encontrados = []
    
    # pkgutil recorre la carpeta f칤sica del paquete
    for finder, name, ispkg in pkgutil.iter_modules(mi_app.plugins.__path__):
        full_name = f"mi_app.plugins.{name}"
        modulo = importlib.import_module(full_name)
        
        # Buscamos una funci칩n est치ndar 'register'
        if hasattr(modulo, 'register'):
            modulo.register()
            plugins_encontrados.append(name)
            
    return plugins_encontrados
```

Con este patr칩n, **simplemente copiando un archivo .py en la carpeta**, el sistema lo detecta y lo carga al iniciar.

---

## `__new__` vs `__init__`: El Nacimiento del Objeto

La mayor칤a usa `__init__` (inicializador). Pero el verdadero constructor es `__new__`.
*   `__new__`: Crea el objeto en memoria (retorna `self`). Es un m칠todo de clase est치tico.
*   `__init__`: Recibe `self` y le pone valores.

**Caso de Uso: Patr칩n Singleton Inmutable**
Si quieres que tu clase devuelva siempre la misma instancia (ej. `None` es siempre el mismo objeto).

```python
class Tierra:
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            print("Creando el planeta...")
            cls._instance = super().__new__(cls)
        return cls._instance

a = Tierra()
b = Tierra()
print(a is b) # True
```

---

## Descriptores de Datos vs Non-Data

En la secci칩n 10 vimos Descriptores simples (`__get__` y `__set__`).
Pero hay una distinci칩n t칠cnica vital.

1.  **Data Descriptor:** Define `__set__` o `__delete__`. Tiene prioridad sobre el `__dict__` de la instancia.
2.  **Non-Data Descriptor:** Solo define `__get__` (ej. m칠todos, `functools.cached_property`). El `__dict__` de la instancia tiene prioridad sobre 칠l.

**El "Lookup Chain" (Cadena de B칰squeda):**
Cuando haces `obj.x`:
1.  Si `x` es Data Descriptor en la clase -> Usa su `__get__`.
2.  Si `x` est치 en `obj.__dict__` -> Usa el valor del dict.
3.  Si `x` es Non-Data Descriptor en la clase -> Usa su `__get__`.
4.  Si no, busca en las clases padre.

Esta jerarqu칤a permite hacer cosas como **Lazy Loading** (Un atributo que no se calcula hasta que se pide, y luego se guarda en el dict para que la pr칩xima vez sea r치pido).

---


---

## Protocolo Descriptor (La Magia Detr치s de `@property`)

쮺칩mo funciona `__get__`, `__set__` y `__delete__`?
Esto es conocimiento arcano de Python.
Si quieres crear un ORM (como Django Models o SQLAlchemy), necesitas esto.

### El Problema de la Repetici칩n
Imagina que tienes 10 atributos que deben ser positivos. Escribir 10 propiedades con `@edad.setter` es aburrido.

### La Soluci칩n: Descriptor
Una clase que controla el acceso a un atributo de OTRA clase.

```python
class EnteroPositivo:
    def __init__(self, nombre_atributo):
        self.nombre = nombre_atributo
        self.attr_interno = f"_{nombre_atributo}"

    def __get__(self, instance, owner):
        if instance is None: return self # Acceso desde la clase
        return getattr(instance, self.attr_interno, 0)

    def __set__(self, instance, value):
        if not isinstance(value, int) or value < 0:
            raise ValueError(f"{self.nombre} debe ser entero positivo")
        setattr(instance, self.attr_interno, value)

class Jugador:
    nivel = EnteroPositivo("nivel")
    vida = EnteroPositivo("vida")
    score = EnteroPositivo("score")

j = Jugador()
j.nivel = 5 # OK
# j.vida = -10 # Error autom치tico
```
Escribimos la l칩gica de validaci칩n UNA VEZ y la reutilizamos N veces.

---

## Patr칩n Registry (Auto-registro)

Supongamos que creas un sistema de plugins. Quieres que al definir una clase, se registre sola en una lista central.
Usamos `__init_subclass__` (el sucesor moderno de las metaclases para este caso).

```python
class WidgetBase:
    _catalogo = {}
    
    def __init_subclass__(cls, tipo=None, **kwargs):
        super().__init_subclass__(**kwargs)
        if tipo:
            WidgetBase._catalogo[tipo] = cls

class BotonRojo(WidgetBase, tipo="boton_danger"):
    pass

class BotonAzul(WidgetBase, tipo="boton_info"):
    pass

# Magia:
print(WidgetBase._catalogo) 
# {'boton_danger': <class 'BotonRojo'>, 'boton_info': <class 'BotonAzul'>}
```
Esto elimina la necesidad de escribir listas gigantes de `if tipo == 'boton': return Boton()`.

---

## Structural Pattern Matching (Python 3.10+)

En componentes complejos, el `if-elif-else` se vuelve inmanejable.
El `match-case` no es solo un switch. Puede desestructurar objetos.

```python
def manejar_evento(evento):
    match evento:
        case {"type": "click", "x": x, "y": y} if x > 100:
            print(f"Click zona derecha: {y}")
        case ["keypress", tecla]:
            print(f"Tecla presionada: {tecla}")
        case Usuario(admin=True, nombre=n):
            print(f"Admin detectado: {n}")
        case _:
            print("Evento desconocido")
```
Esto simplifica dr치sticamente el manejo de mensajes en sistemas distribuidos o GUIs.

---


---

## Duck Typing vs Protocolos Est치ticos

En la secci칩n 8 hablamos de ABCs. Pero el Python moderno prefiere **Protocolos** (`typing.Protocol`).
Es "Duck Typing Checkeable est치ticamente".

```python
from typing import Protocol

class Volador(Protocol):
    def volar(self) -> None:
        ...

def despegar(ave: Volador):
    ave.volar()
    
class Pato:
    def volar(self): print("Cuack, vuelo") # No hereda de Volador, pero CUMPLE la interfaz

despegar(Pato()) # El IDE y Mypy lo marcan como correcto.
```
Esto permite polimorfismo estructural sin la rigidez de la herencia.

---

## Internals: `__slots__` y la memoria

Normalmente `class A: pass` usa un `dict` para atributos.
*   `dict` overhead: ~240 bytes m칤nimo (Hash table dispersa).
*   Si creas 1 mill칩n de objetos, son 240MB de RAM solo en overhead.

**`__slots__` al rescate:**
Le dice a Python: "Esta clase SOLO tendr치 los atributos 'x' e 'y'. No uses diccionario".
Python reserva memoria contigua estilo C-struct.
*   Overhead: ~16 bytes.
*   Diferencia: 15 veces menos RAM.
*   Desventaja: No puedes a침adir atributos nuevos din치micamente (`obj.nuevo = 1` falla).

---

## Caso de Estudio Real: Creando un Mini-ORM con Metaclases

Para entender la potencia de las metaclases, vamos a recrear el comportamiento m치gico de Django/SQLAlchemy.
Queremos que al definir una clase, SQL se genere solo.

```python
class Campo:
    def __init__(self, tipo): self.tipo = tipo

class ModelMeta(type):
    def __new__(cls, name, bases, dct):
        # 1. Interceptar definici칩n de la clase
        tabla_name = name.lower()
        campos_sql = []
        
        for key, value in dct.items():
            if isinstance(value, Campo):
                campos_sql.append(f"{key} {value.tipo}")
        
        # 2. Generar SQL de creaci칩n
        dct['_create_sql'] = f"CREATE TABLE {tabla_name} ({', '.join(campos_sql)});"
        
        return super().__new__(cls, name, bases, dct)

class Modelo(metaclass=ModelMeta):
    pass

# --- Uso del Usuario ---
class Usuario(Modelo):
    id = Campo("INTEGER PRIMARY KEY")
    nombre = Campo("TEXT")
    email = Campo("VARCHAR(100)")

# 춰Magia! La SQL se gener칩 sola al definir la clase.
print(Usuario._create_sql)
# CREATE TABLE usuario (id INTEGER PRIMARY KEY, nombre TEXT, email VARCHAR(100));
```
As칤 funcionan los ORMs modernos. La metaclase lee los atributos de clase y configura la "magia" antes de que siquiera instancies un objeto.

---

## Arquitectura de Plugins (Auto-Discovery)

Imagina un sistema como Photoshop. Quieres que otros desarrolladores creen filtros sin tocar tu c칩digo fuente.

**Estructura de Carpetas:**
```text
mi_app/
    core.py
    plugins/
        filtro_byn.py
        filtro_sepia.py
```

**C칩digo del Loader (`core.py`):**
```python
import importlib
import pkgutil
import mi_app.plugins

def cargar_plugins():
    plugins_encontrados = []
    
    # pkgutil recorre la carpeta f칤sica del paquete
    for finder, name, ispkg in pkgutil.iter_modules(mi_app.plugins.__path__):
        full_name = f"mi_app.plugins.{name}"
        modulo = importlib.import_module(full_name)
        
        # Buscamos una funci칩n est치ndar 'register'
        if hasattr(modulo, 'register'):
            modulo.register()
            plugins_encontrados.append(name)
            
    return plugins_encontrados
```

Con este patr칩n, **simplemente copiando un archivo .py en la carpeta**, el sistema lo detecta y lo carga al iniciar.

---

## `__new__` vs `__init__`: El Nacimiento del Objeto

La mayor칤a usa `__init__` (inicializador). Pero el verdadero constructor es `__new__`.
*   `__new__`: Crea el objeto en memoria (retorna `self`). Es un m칠todo de clase est치tico.
*   `__init__`: Recibe `self` y le pone valores.

**Caso de Uso: Patr칩n Singleton Inmutable**
Si quieres que tu clase devuelva siempre la misma instancia (ej. `None` es siempre el mismo objeto).

```python
class Tierra:
    _instance = None
    
    def __new__(cls):
        if cls._instance is None:
            print("Creando el planeta...")
            cls._instance = super().__new__(cls)
        return cls._instance

a = Tierra()
b = Tierra()
print(a is b) # True
```

---

## Descriptores de Datos vs Non-Data

En la secci칩n 10 vimos Descriptores simples (`__get__` y `__set__`).
Pero hay una distinci칩n t칠cnica vital.

1.  **Data Descriptor:** Define `__set__` o `__delete__`. Tiene prioridad sobre el `__dict__` de la instancia.
2.  **Non-Data Descriptor:** Solo define `__get__` (ej. m칠todos, `functools.cached_property`). El `__dict__` de la instancia tiene prioridad sobre 칠l.

**El "Lookup Chain" (Cadena de B칰squeda):**
Cuando haces `obj.x`:
1.  Si `x` es Data Descriptor en la clase -> Usa su `__get__`.
2.  Si `x` est치 en `obj.__dict__` -> Usa el valor del dict.
3.  Si `x` es Non-Data Descriptor en la clase -> Usa su `__get__`.
4.  Si no, busca en las clases padre.

Esta jerarqu칤a permite hacer cosas como **Lazy Loading** (Un atributo que no se calcula hasta que se pide, y luego se guarda en el dict para que la pr칩xima vez sea r치pido).

---

<div align="center">

[拘勇 Anterior: 2.2 Librer칤a Est치ndar](2.2.md) &nbsp;&nbsp;|&nbsp;&nbsp; [Men칰 Unidad](README.md) &nbsp;&nbsp;|&nbsp;&nbsp; [Siguiente: 2.4 Empaquetado y Distribuci칩n](2.4.md) 俱뫮잺

</div>
