# 2.2 Uso de librerías proporcionadas por el lenguaje

## Filosofía "Batteries Included"

La característica más famosa de Python no es su sintaxis, sino su **Biblioteca Estándar**.
La filosofía de Guido van Rossum fue que Python debería servir para tareas del mundo real inmediatamente después de instalarse, sin obligar al usuario a descargar paquetes extra.

Mientras que en C++ o Node.js necesitas instalar librerías para casi todo (hasta para hacer testing), Python incluye servidores HTTP, bases de datos (SQLite), interfaces gráficas (Tkinter), compresión (gzip) y manejo de hilos de fábrica.

Esta sección es un recorrido por las joyas de la corona que todo experto debe conocer.

---

## Sistema de Archivos y SO Moderno: `pathlib`

Olvida `os.path`. Eso es Python 2.
Desde Python 3.4, `pathlib` ofrece una interfaz Orientada a Objetos para manipular rutas.

### ¿Por qué `pathlib`?
Tratar las rutas como strings (`"C:\\user\\data"`) es un error. Las rutas son objetos semánticos.

**Comparativa:**

| Tarea | Estilo Viejo (`os.path`) | Estilo Nuevo (`pathlib`) |
| :--- | :--- | :--- |
| Unir rutas | `os.path.join(dir, "file.txt")` | `dir / "file.txt"` (Operador sobrecargado) |
| Crear carpeta | `os.makedirs(path, exist_ok=True)` | `path.mkdir(parents=True, exist_ok=True)` |
| Leer texto | `with open(p) as f: f.read()` | `path.read_text()` |
| Obtener nombre | `os.path.split(p)[1]` | `path.name` |
| Cambiar extensión | (Complejo string slice) | `path.with_suffix('.bak')` |

**Ejemplo Robusto:**
```python
from pathlib import Path

# Base del usuario (Cross-platform: C:\Users\Yo o /home/yo)
HOME = Path.home()
APP_DIR = HOME / ".miapp"
LOG_FILE = APP_DIR / "logs" / "evento.log"

# Crear estructura si no existe
LOG_FILE.parent.mkdir(parents=True, exist_ok=True)

# Escribir
LOG_FILE.write_text("Iniciando sistema...", encoding="utf-8")
```

---

## Serialización de Datos: `json` y `pickle`

La web habla JSON. Python habla Objetos. Necesitamos un traductor.

### JSON (Intercambio de Datos)
Soporta tipos primitivos: dict, list, str, int, float, bool, None.
*   `dump/load`: Trabajan con **archivos**.
*   `dumps/loads` (la s es de string): Trabajan con **cadenas** en memoria.

**Problema común (Datetime):**
JSON no soporta objetos `datetime`. Si intentas serializar una fecha, falla.
*Solución:* Convertir a string ISO antes (`.isoformat()`).

### Pickle (Persistencia Nativa)
Es un protocolo binario exclusivo de Python.
*   **Poder:** Guarda CUALQUIER cosa (clases, funciones, grafos cíclicos).
*   **Peligro Crítico:** **Inseguro**.
    Si haces `pickle.load()` de un archivo que te mandó un hacker, él puede ejecutar código arbitrario en tu máquina (Remote Code Execution).
    *Regla:* Solo usa pickle con archivos que TÚ creaste y controlas. Nunca para recibir datos de internet.

---

## Colecciones de Alto Rendimiento: `collections`

Las listas y diccionarios son geniales, pero a veces necesitas estructuras especializadas.

### A. `Counter` (Multiset)
Cuenta ocurrencias automáticamente.
```python
from collections import Counter
ventas = ["manzana", "pera", "manzana", "uva", "manzana"]
c = Counter(ventas)
print(c) # {'manzana': 3, 'pera': 1, 'uva': 1}
print(c.most_common(1)) # [('manzana', 3)]
```

### B. `defaultdict`
Evita el fastidioso `KeyError`. Si la llave no existe, la crea con un valor por defecto.
```python
from collections import defaultdict
# Agrupar palabras por inicial
grupos = defaultdict(list)
palabras = ["gato", "perro", "ganzo"]
for p in palabras:
    grupos[p[0]].append(p) 
# grupos['g'] ya era una lista vacía automáticamente
```

### C. `deque` (Double Ended Queue)
Las listas de Python son lentas si insertas al principio (`list.insert(0, x)`). Tienen que mover toda la memoria.
`deque` es una lista ligada optimizada para insertar/borrar en ambos extremos O(1).
Vital para colas y pilas.

---

## Algoritmos de Bisección: `bisect`

Mantener una lista ordenada es costoso si usas `sort()` cada vez que insertas algo (O(N log N)).
`bisect` permite insertar un elemento en una lista ordenada **manteniendo el orden** (O(N), pero muy optimizado en C).

```python
import bisect
scores = [100, 200, 500, 900]
# Insertar 350 en su lugar correcto
bisect.insort(scores, 350)
print(scores) # [100, 200, 350, 500, 900]
```
Uso: Leaderboards de juegos, series de tiempo.

---

## Iteración Avanzada: `itertools`

El módulo favorito de los programadores funcionales. Permite manipular flujos de datos de manera eficiente en memoria.

*   `chain()`: Une varias listas sin crear una copia nueva gigante.
*   `cycle()`: Repite una secuencia infinitamente (ej. luces de semáforo).
*   `product()`: Producto cartesiano (bucles for anidados).
    ```python
    # Evita el "Arrow Head" de indentación
    for x, y in itertools.product(range(10), range(5)):
        ...
    ```

---

## Depuración y Logs: `logging`

El uso de `print` para depurar es "amateur". En producción, nadie mira la consola. Necesitas guardar logs en disco con niveles de severidad.

### Niveles de Log
1.  **DEBUG:** Detalles ínfimos solo para el desarrollador.
2.  **INFO:** "El servicio inició", "Usuario logueado".
3.  **WARNING:** "Disco al 80%", "API lenta". Algo va mal pero seguimos.
4.  **ERROR:** "Falló conexión BD". Una operación falló.
5.  **CRITICAL:** "Servicio caído". El programa debe detenerse.

### Configuración Profesional
No uses `logging.basicConfig` en librerías. Define loggers nombrados.

```python
import logging

logger = logging.getLogger(__name__)

def procesar():
    try:
        logger.info("Iniciando proceso...")
        ...
    except Exception:
        logger.exception("Error fatal") # Imprime el stack trace completo
```

---

## Tipos de Datos Numéricos: `decimal`

Los flotantes (`float`) tienen errores de precisión. `0.1 + 0.2 != 0.3` en computadoras (es `0.30000000000000004`).
Esto es inaceptable para **Dinero**.

Usa `decimal` para cálculos financieros precisos.
```python
from decimal import Decimal
precio = Decimal("10.50")
impuesto = Decimal("0.16")
total = precio * (1 + impuesto) # Exactitud perfecta
```

---

## Interfaz de Sistema: `sys` y `argparse`

### `sys`
Controla el intérprete.
*   `sys.argv`: Argumentos de línea de comandos.
*   `sys.exit(code)`: Terminar programa. (0=Bien, 1=Error).
*   `sys.path`: Rutas de importación.

### `argparse`
Si estás analizando `sys.argv` manualmente, para. Usa `argparse` para crear CLIs profesionales con ayuda automática (`--help`).

```python
import argparse
parser = argparse.ArgumentParser(description="Calculadora")
parser.add_argument("--sumar", nargs=2, type=int, help="Suma dos números")
args = parser.parse_args()
```

---

## Resumen de la Standard Lib

Si vas a programar en Python, imprime esta tabla mental:

| Problema | Módulo Solución |
| :--- | :--- |
| Rutas y Archivos | `pathlib` |
| Fechas y Horas | `datetime`, `zoneinfo` |
| Expresiones Regulares | `re` |
| Matemáticas Complejas | `math`, `statistics` |
| Datos Binarios | `struct` |
| Aleatoriedad | `random`, `secrets` (criptografía) |
| Internet básico | `urllib` (pero usa `requests` externo mejor) |
| Ejecutar comandos | `subprocess` |


---

## Rompiendo la Barrera de Velocidad: `ctypes`

Python es lento. C es rápido.
A veces necesitas llamar a una función de C desde Python.

### Cargar una DLL/.so compartida
```python
import ctypes

# Cargar libc (C Standard Library)
if sys.platform == "win32":
    libc = ctypes.cdll.msvcrt
else:
    libc = ctypes.CDLL("libc.so.6")

# Llamar a printf de C
libc.printf(b"Hola desde C puro\n")
```
Esto es la base de cómo funcionan `numpy` y `tensorflow`. No calculan en Python; calculan en C/C++ y Python es solo el control remoto.

---

## Concurrencia Real: `multiprocessing` vs `threading`

Aquí yace la entrevista de trabajo de Senior Python Dev.

### El Global Interpreter Lock (GIL)
CPython tiene un candado (mutex) que impide que dos hilos de Python ejecuten código (bytecode) simultáneamente en el mismo proceso.
*   **Consecuencia:** El multithreading en Python **NO USA** múltiples núcleos de CPU para tareas de cálculo puro (CPU-bound).
*   *Multithreading* solo sirve para I/O (esperar red, disco).

### La Solución: Multi-Procesos
Si quieres usar los 8 núcleos de tu CPU para minar Bitcoins o procesar imágenes:
Usa `multiprocessing`. Crea procesos nuevos (con su propia memoria y GIL propio).

```python
from multiprocessing import Pool

def calculo_pesado(n):
    return n * n

if __name__ == "__main__":
    with Pool(4) as p: # 4 núcleos
        print(p.map(calculo_pesado, [1, 2, 3]))
```

---

## Asyncio: El Futuro de la I/O

El modelo clásico espera: `archivo.read()` detiene todo.
`asyncio` (Python 3.5+) introduce el patrón `async/await` (similar a Node.js).

*   **Single-threaded:** Usa un solo hilo.
*   **Event Loop:** Cuando hay una espera (I/O), suelta el control para que otra tarea corra.

```python
import asyncio

async def saludar():
    print("Hola")
    await asyncio.sleep(1) # Cede el control, no bloquea
    print("Mundo")

asyncio.run(saludar())
```
(Veremos esto a profundidad en la Unidad 3, pero es parte de la Standard Lib).

---

## Gestión de Memoria Avanzada

Python usa Reference Counting + Garbage Collector (Generacional) para ciclos.

### `weakref` (Referencias Débiles)
A veces quieres guardar una referencia a un objeto (ej. en una caché) sin impedir que el Garbage Collector lo borre si nadie más lo usa.

```python
import weakref

class Cache:
    def __init__(self):
        self._data = weakref.WeakValueDictionary()
    
    def add(self, key, value):
        self._data[key] = value
        # Si 'value' pierde todas sus otras referencias fuertes,
        # desaparecerá automáticamente de este diccionario.
```

### `gc` (Control Manual del Basurero)
Puedes desactivar el GC para ganar performance en juegos (y activarlo manualmente en pantallas de carga).
```python
import gc
gc.disable()
# ... loop crítico ...
gc.collect() # Forzar limpieza
```

---


---

## The Buffer Protocol (Memoria de Alto Rendimiento)

Este es un tema avanzado que separa a los "Pythonistas" de los "Ingenieros de Software".
Python permite acceder a la memoria cruda (bytes) de un objeto sin copiarla. Esto es el **Buffer Protocol**.

### `memoryview`
Imagina que tienes una imagen de 100MB en variable `img`.
Si haces `recorte = img[0:1000]`, Python (normalmente) copiaría esos datos -> Lento.
Con `memoryview`, creas una "ventana" a la memoria existente. Cero copias.

```python
data = bytearray(b"x" * 1000000) # 1MB
mv = memoryview(data)
chunk = mv[0:10] # No copia datos, solo apunta
chunk[0] = 65 # Cambia 'x' por 'A' en el original
print(data[0:5]) # bytearray(b'Axxxx')
```
Esto es crucial para manejo de redes, archivos grandes y procesamiento de imágenes.

### `array` (Arreglos Eficientes)
Si necesitas almacenar 1 millón de enteros, una `list` es ineficiente (cada entero es un objeto `PyObject` completo con referencias, tipo, etc. -> 28 bytes mínimo).
El módulo `array` guarda los datos como en C (4 bytes por entero).

```python
import array
numeros = array.array('i', [1, 2, 3]) # 'i' = signed int
```

---

## Internals: ¿Por qué `deque` es más rápido que `list`?

Para entender esto, debemos mirar el código C de CPython (`Modules/_collectionsmodule.c` vs `Objects/listobject.c`).

### Anatomía de `list` (Vector Dinámico)
Internamente, una lista es un puntero a un array contiguo de punteros `PyObject**`.
*   `[Ptr1][Ptr2][Ptr3][Empty][Empty]` (Sobre-provisionado para crecer).
*   **Insertar al inicio (`insert(0, x)`):** Catastrófico. Debe desplazar TODOS los punteros a la derecha. Costo **O(N)**.

### Anatomía de `deque` (Doubly Linked List of Blocks)
Un `deque` NO es una lista ligada simple (nodo a nodo), eso fragmentaría la caché del CPU.
Es una **Lista Ligada de Bloques** de contigüidad.
*   `[Block1] <-> [Block2] <-> [Block3]`
*   Cada bloque guarda (por ejemplo) 64 elementos.
*   **Insertar al inicio:** Simplemente escribe en el espacio vacío del `Block1` o crea un `Block0` nuevo y lo enlaza. Costo **O(1)**.

### `dict` Internals (Hash Tables)
Desde Python 3.6, el diccionario es ordenado. ¿Cómo?
Antes era una *Sparse Table* gigante. Ahora son dos estructuras:
1.  **Indices:** Array denso de bytes `[0, 2, -1, 1]` (índices a la tabla de entradas).
2.  **Entries:** Array compacto de structs `(hash, key_ptr, val_ptr)`.
Esto redujo el uso de RAM un 20-25% y ganó velocidad de iteración.

---

## Context Variables (`contextvars`)

Introducido en Python 3.7. Es el reemplazo moderno de `threading.local()` para el mundo asíncrono.
Permite tener variables "globales" que son locales al contexto de ejecución (task) actual.

**Escenario:**
Tienes un servidor web (FastAPI/Django) manejando 100 requests concurrentes en un solo hilo (Async).
¿Cómo guardas el `User-ID` actual accesible globalmente sin pasarlo por cada función?

```python
import contextvars

user_ctx = contextvars.ContextVar("user")

async def process_request(user):
    user_ctx.set(user) # Solo visible para esta Task
    await db_query()

async def db_query():
    # Magia: Recupera el user correcto aunque haya 100 tareas mezcladas
    current_user = user_ctx.get() 
    print(f"Logueando acceso de {current_user}")
```
Esto es la espina dorsal de frameworks modernos.

---

## Programación Funcional en la StdLib (`functools`)

Python no es Haskell, pero tiene herramientas poderosas.

### `lru_cache` (Memoización)
El decorador `@lru_cache` (Least Recently Used) guarda resultados de funciones puras.
Si llamas `fib(30)` dos veces, la segunda vez retorna instantáneamente sin calcular.

```python
from functools import lru_cache

@lru_cache(maxsize=128)
def fib(n):
    if n < 2: return n
    return fib(n-1) + fib(n-2)
```

### `singledispatch` (Sobrecarga de Funciones)
Python no soporta sobrecarga nativa (`void foo(int x)`, `void foo(char* x)`).
`singledispatch` lo permite basado en el tipo del primer argumento.

```python
from functools import singledispatch

@singledispatch
def imprimir(dato):
    print("Dato genérico:", dato)

@imprimir.register(int)
def _(dato):
    print("Número entero:", dato * 2)

@imprimir.register(list)
def _(dato):
    print("Lista de elementos:", len(dato))

imprimir(10)   # -> Número entero: 20
imprimir([1])  # -> Lista de elementos: 1
```

---


---

## Advanced Collections: Más allá de listas y diccionarios

La librería estándar tiene estructuras de datos optimizadas en C que pocos usan.

### `ChainMap`: Diccionarios en Capas
Ideal para gestión de configuración (Env Vars > Config File > Defaults).
Busca en el primero, luego en el segundo, etc.
```python
from collections import ChainMap
import os

defaults = {'theme': 'dark', 'port': 8080}
env_vars = {'port': 5000} # Simulado de os.environ
cli_args = {'debug': True}

config = ChainMap(cli_args, env_vars, defaults)

print(config['port'])  # 5000 (Viene de env_vars)
print(config['theme']) # dark (Viene de defaults)
```
No copia datos. Es una vista virtual. Rapidísimo.

### `namedtuple` vs `TypedDict`
Para estructuras de datos ligeras.
*   `namedtuple`: Inmutable. Ahorra memoria (como tuplas). Acceso por punto `p.x`.
*   `TypedDict`: Mutable. Solo para Type Hinting. En runtime es un dict normal.

---

## Maestría en Iteradores (`itertools`)

Funciones que crean iteradores para bucles eficientes.

### `cycle` y `repeat`
*   `cycle([1,2])` -> 1, 2, 1, 2, 1, 2... (Infinito). Útil para "Round Robin" load balancing.
*   `repeat(10, 3)` -> 10, 10, 10.

### `groupby`
Agrupa datos consecutivos. **OJO:** Los datos deben estar ordenados primero.
```python
from itertools import groupby

data = [('A', 1), ('A', 2), ('B', 5), ('A', 3)]
data.sort() # Vital

for key, group in groupby(data, lambda x: x[0]):
    print(key, list(group))
# A [('A', 1), ('A', 2), ('A', 3)]
# B [('B', 5)]
```

### Receta: Sliding Window (Ventana Deslizante)
Procesar datos en bloques solapados (ej. promedio móvil).
```python
def sliding_window(iterable, n=2):
    # s -> (s0,s1), (s1,s2), (s2,s3), ...
    it = iter(iterable)
    window = collections.deque(islice(it, n), maxlen=n)
    if len(window) == n:
        yield tuple(window)
    for elem in it:
        window.append(elem)
        yield tuple(window)
```

---

## Programación Funcional con `functools`

### `lru_cache` (Memoización)
Acelera funciones recursivas o costosas guardando el resultado en RAM.
```python
from functools import lru_cache

@lru_cache(maxsize=128)
def fib(n):
    if n < 2: return n
    return fib(n-1) + fib(n-2)

# Sin cache: O(2^n). Con cache: O(n).
```

### `singledispatch` (Sobrecarga de funciones)
Python no soporta sobrecarga (`void func(int x)`, `void func(char x)`).
`singledispatch` lo simula.
```python
from functools import singledispatch

@singledispatch
def procesar(dato):
    print("Genérico:", dato)

@procesar.register
def _(dato: int):
    print("Entero:", dato * 2)

@procesar.register
def _(dato: list):
    print("Lista:", len(dato))

procesar(10) # Entero
procesar([1,2]) # Lista
```

---

## Context Managers Avanzados (`contextlib`)

Ya conoces `with open(...)`. ¿Cómo crear los tuyos sin clases?

### `@contextmanager`
Usa generadores. Lo que está antes del `yield` es el `__enter__`, lo que está después es `__exit__`.
```python
from contextlib import contextmanager
import time

@contextmanager
def cronometro(etiqueta):
    start = time.time()
    try:
        yield
    finally:
        end = time.time()
        print(f"{etiqueta}: {end - start} segundos")

with cronometro("Descarga"):
    descargar_archivo()
```

### `suppress`
Ignorar excepciones específicas elegantemente.
```python
from contextlib import suppress
import os

with suppress(FileNotFoundError):
    os.remove("archivo_que_quizas_no_existe.tmp")
# Si no existe, no falla. Continúa.
```

---

## Serialización Binaria: `struct`

A veces debes hablar con C o leer archivos binarios viejos (headers de imágenes, protocolos de red).
`struct` empaqueta datos Python en bytes C.
```python
import struct

# Empaquetar: int (4 bytes), short (2 bytes), char[5]
binary_data = struct.pack('i h 5s', 105, 99, b'hola')

# Desempaquetar
id, val, msg = struct.unpack('i h 5s', binary_data)
```

---

## Weak References (`weakref`)

Python usa contadores de referencia. Si A apunta a B, B vive.
Una WeakRef permite apuntar a B **sin** incrementar su contador. Si nadie más usa B, el GC lo borra y tu WeakRef pasa a devolver `None`.
*   **Uso:** Cachés. No quieres mantener objetos vivos solo porque están en la caché.

```python
import weakref

class Cache:
    def __init__(self):
        self._data = weakref.WeakValueDictionary()
    
    def add(self, key, value):
        self._data[key] = value

# Si 'value' deja de usarse en el resto del programa, desaparece de _data automáticamente.
```

---


---

## Advanced Collections: Más allá de listas y diccionarios

La librería estándar tiene estructuras de datos optimizadas en C que pocos usan.

### `ChainMap`: Diccionarios en Capas
Ideal para gestión de configuración (Env Vars > Config File > Defaults).
Busca en el primero, luego en el segundo, etc.
```python
from collections import ChainMap
import os

defaults = {'theme': 'dark', 'port': 8080}
env_vars = {'port': 5000} # Simulado de os.environ
cli_args = {'debug': True}

config = ChainMap(cli_args, env_vars, defaults)

print(config['port'])  # 5000 (Viene de env_vars)
print(config['theme']) # dark (Viene de defaults)
```
No copia datos. Es una vista virtual. Rapidísimo.

### `namedtuple` vs `TypedDict`
Para estructuras de datos ligeras.
*   `namedtuple`: Inmutable. Ahorra memoria (como tuplas). Acceso por punto `p.x`.
*   `TypedDict`: Mutable. Solo para Type Hinting. En runtime es un dict normal.

---

## Maestría en Iteradores (`itertools`)

Funciones que crean iteradores para bucles eficientes.

### `cycle` y `repeat`
*   `cycle([1,2])` -> 1, 2, 1, 2, 1, 2... (Infinito). Útil para "Round Robin" load balancing.
*   `repeat(10, 3)` -> 10, 10, 10.

### `groupby`
Agrupa datos consecutivos. **OJO:** Los datos deben estar ordenados primero.
```python
from itertools import groupby

data = [('A', 1), ('A', 2), ('B', 5), ('A', 3)]
data.sort() # Vital

for key, group in groupby(data, lambda x: x[0]):
    print(key, list(group))
# A [('A', 1), ('A', 2), ('A', 3)]
# B [('B', 5)]
```

### Receta: Sliding Window (Ventana Deslizante)
Procesar datos en bloques solapados (ej. promedio móvil).
```python
def sliding_window(iterable, n=2):
    # s -> (s0,s1), (s1,s2), (s2,s3), ...
    it = iter(iterable)
    window = collections.deque(islice(it, n), maxlen=n)
    if len(window) == n:
        yield tuple(window)
    for elem in it:
        window.append(elem)
        yield tuple(window)
```

---

## Programación Funcional con `functools`

### `lru_cache` (Memoización)
Acelera funciones recursivas o costosas guardando el resultado en RAM.
```python
from functools import lru_cache

@lru_cache(maxsize=128)
def fib(n):
    if n < 2: return n
    return fib(n-1) + fib(n-2)

# Sin cache: O(2^n). Con cache: O(n).
```

### `singledispatch` (Sobrecarga de funciones)
Python no soporta sobrecarga (`void func(int x)`, `void func(char x)`).
`singledispatch` lo simula.
```python
from functools import singledispatch

@singledispatch
def procesar(dato):
    print("Genérico:", dato)

@procesar.register
def _(dato: int):
    print("Entero:", dato * 2)

@procesar.register
def _(dato: list):
    print("Lista:", len(dato))

procesar(10) # Entero
procesar([1,2]) # Lista
```

---

## Context Managers Avanzados (`contextlib`)

Ya conoces `with open(...)`. ¿Cómo crear los tuyos sin clases?

### `@contextmanager`
Usa generadores. Lo que está antes del `yield` es el `__enter__`, lo que está después es `__exit__`.
```python
from contextlib import contextmanager
import time

@contextmanager
def cronometro(etiqueta):
    start = time.time()
    try:
        yield
    finally:
        end = time.time()
        print(f"{etiqueta}: {end - start} segundos")

with cronometro("Descarga"):
    descargar_archivo()
```

### `suppress`
Ignorar excepciones específicas elegantemente.
```python
from contextlib import suppress
import os

with suppress(FileNotFoundError):
    os.remove("archivo_que_quizas_no_existe.tmp")
# Si no existe, no falla. Continúa.
```

---

## Serialización Binaria: `struct`

A veces debes hablar con C o leer archivos binarios viejos (headers de imágenes, protocolos de red).
`struct` empaqueta datos Python en bytes C.
```python
import struct

# Empaquetar: int (4 bytes), short (2 bytes), char[5]
binary_data = struct.pack('i h 5s', 105, 99, b'hola')

# Desempaquetar
id, val, msg = struct.unpack('i h 5s', binary_data)
```

---

## Weak References (`weakref`)

Python usa contadores de referencia. Si A apunta a B, B vive.
Una WeakRef permite apuntar a B **sin** incrementar su contador. Si nadie más usa B, el GC lo borra y tu WeakRef pasa a devolver `None`.
*   **Uso:** Cachés. No quieres mantener objetos vivos solo porque están en la caché.

```python
import weakref

class Cache:
    def __init__(self):
        self._data = weakref.WeakValueDictionary()
    
    def add(self, key, value):
        self._data[key] = value

# Si 'value' deja de usarse en el resto del programa, desaparece de _data automáticamente.
```

---

<div align="center">

[⬅️ Anterior: 2.1 Conceptos](2.1.md) &nbsp;&nbsp;|&nbsp;&nbsp; [Menú Unidad](README.md) &nbsp;&nbsp;|&nbsp;&nbsp; [Siguiente: 2.3 Componentes Propios](2.3.md) ➡️

</div>
