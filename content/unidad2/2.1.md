# 2.1 Definición conceptual de componentes, paquetes y librerías

## La Crisis del Código Espagueti

Cuando un programador novato empieza, escribe todo en un solo archivo `proyecto.py`. 
A las 100 líneas, es manejable. 
A las 1,000 líneas, es difícil. 
A las 10,000 líneas, es **imposible**.

La **Modularidad** no es una sugerencia; es la única forma en que la humanidad ha logrado construir sistemas complejos, desde rascacielos hasta sistemas operativos. Si no divides el problema, el problema te aplasta.

### Cohesión y Acoplamiento: El Yin y el Yang
Estos dos conceptos definen la calidad de tu arquitectura.

*   **Cohesión (Busca maximizarla):**
    Es la medida de qué tan relacionadas están las partes dentro de un módulo.
    *   *Alta Cohesión:* Un módulo `email.py` contiene funciones para conectar SMTP, formatear HTML y adjuntar archivos. Todo tiene sentido junto.
    *   *Baja Cohesión:* Un módulo `utils.py` contiene una función para calcular IVA (`def iva`), otra para dibujar una ventana (`def ventana`) y otra para conectar a SQL (`def connect`). Es un basurero.

*   **Acoplamiento (Busca minimizarlo):**
    Es la medida de qué tan interdependientes son dos módulos distintos.
    *   *Bajo Acoplamiento (Loose Coupling):* Si cambias la base de datos de MySQL a Postgres en `db.py`, el módulo `gui.py` no debería enterarse ni romperse.
    *   *Alto Acoplamiento:* `gui.py` importa directamente `mysql.connector`. Si cambias la BD, tienes que reescribir la GUI. (ERROR).

---

## La Jerarquía de Organización en Python

Python tiene una terminología estricta que a menudo se usa mal en la calle. Vamos a definirla con precisión académica.

### Script
Un archivo `.py` pensado para ser **ejecutado** directamente por el usuario.
*   Contiene el bloque: `if __name__ == "__main__":`
*   No suele exportar clases útiles para otros.

### Módulo (Module)
Cualquier archivo `.py` pensado para ser **importado**.
*   Desde el punto de vista del SO, es un archivo.
*   Desde el punto de vista de Python, es un objeto tipo `module`.
*   El nombre del módulo es el nombre del archivo sin extensión.

### Paquete (Package)
Es una **carpeta** (directorio) que contiene módulos y un archivo especial `__init__.py`.
*   Permite espacios de nombres jerárquicos: `scipy.optimize.linear`.
*   `scipy`: Paquete raíz.
*   `optimize`: Sub-paquete.
*   `linear`: Módulo.

**Namespace Packages (Python 3.3+):**
Carpetas sin `__init__.py`. Permiten que librerías distribuidas separadamente compartan un nombre raíz (ej. `azure-storage` y `azure-mgmt` ambas viven bajo `azure/`).

### Librería (Library)
No es un término técnico de Python, sino un concepto abstracto.
Conjunto de paquetes publicados para resolver un problema general.
*   `requests` es una librería (que internamente es un paquete).

### Componente (Component)
Depende del contexto.
*   **En GUI:** Un widget (Botón).
*   **En Arquitectura:** Una pieza de software que expone una interfaz clara y oculta su implementación, desplegable independientemente.
*   *Ejemplo:* Un microservicio o una DLL.

---

## El Sistema de Importación (Under the Hood)

Cuando escribes `import numpy`, Python no hace magia. Sigue un algoritmo determinista complejo.

### El Algoritmo de Búsqueda
1.  **Caché (`sys.modules`):**
    Python revisa si el módulo ya fue cargado antes. Si sí, devuelve la referencia en RAM. (Por esto los imports son baratos después del primero).
2.  **Built-in:**
    Revisa si es un módulo compilado dentro del intérprete (`sys`, `time`).
3.  **Variable `sys.path`:**
    Recorre una lista de directorios buscando la carpeta o archivo `.py`.

**Contenido típico de `sys.path`:**
1.  El directorio del script actual ( Prioridad máxima - ¡Peligro de Shadowing!).
2.  `PYTHONPATH` (Variable de entorno).
3.  Librería Estándar (`/usr/lib/python3.10`).
4.  Site-packages (`.venv/lib/python3.10/site-packages`).

**El Peligro del Shadowing:**
Si creas un archivo llamado `email.py` en tu carpeta, y tratas de hacer `import email` (para usar la librería estándar), Python cargará **TU** archivo, no el oficial, y tu programa fallará con errores extraños. **Nunca llames a tus archivos igual que librerías estándar.**

---

## El Archivo `__init__.py`

Aunque en Python 3.3+ es opcional para Namespace Packages, para paquetes regulares **sigue siendo obligatorio/recomendado**.

### Usos Profesionales

#### A. Inicialización
Código que corre automáticamente al importar el paquete.
```python
# database/__init__.py
print("Conectando a BD...") # Se ejecuta al hacer 'import database'
```

#### B. Patrón Facade (Fachada) - API Pública
Imagina esta estructura interna fea:
`mi_lib/sub_a/sub_b/core_implementacion_v2.py` -> Clase `Calculadora`.

El usuario no quiere escribir:
`from mi_lib.sub_a.sub_b.core_implementacion_v2 import Calculadora`

En `mi_lib/__init__.py`:
```python
# Importamos la clase interna y la exponemos en el nivel superior
from .sub_a.sub_b.core_implementacion_v2 import Calculadora

__all__ = ["Calculadora"]
```
Ahora el usuario hace:
`from mi_lib import Calculadora`

---

## Importaciones Relativas vs Absolutas

Supongamos:
```text
paquete/
├── modulo_a.py
└── sub/
    └── modulo_b.py
```

### Import Absoluto (Recomendado PEP 8)
En `modulo_b.py`:
`from paquete import modulo_a`
*   **Pros:** Claro. Funciona aunque muevas `modulo_b` a otra carpeta.
*   **Contras:** Si renombras el paquete raíz, debes refactorizar todo.

### Import Relativo (Punto)
En `modulo_b.py`:
`from .. import modulo_a`
*   `.`: Directorio actual.
*   `..`: Directorio padre.
*   **Pros:** El paquete es portable.
*   **Contras:** Falla si ejecutas `modulo_b.py` como script (`python modulo_b.py`) porque el "padre" no está en `sys.path`. Solo funciona usando `python -m paquete.sub.modulo_b`.

---

## Importaciones Circulares (El Enemigo)

**Escenario:**
*   `usuario.py` importa `grupo.py` (para saber a qué grupo pertenece).
*   `grupo.py` importa `usuario.py` (para listar sus miembros).

Python intenta cargar Usuario -> Pausa -> Carga Grupo -> Pausa -> Carga Usuario...
Detecta el ciclo y lanza `ImportError`.

### Soluciones Arquitectónicas
1.  **Refactorizar (Dependency Injection):** Extraer las definiciones comunes (interfaces) a un tercer módulo `types.py` que ambos importen.
2.  **Import Diferido:** Mover el `import` dentro de la función/método, no al inicio del archivo.
    ```python
    # usuario.py
    def get_grupo(self):
        from .grupo import Grupo # Se ejecuta solo al llamar el método
        return Grupo.buscar(self.id)
    ```
3.  **Tipado con `TYPE_CHECKING`:**
    Si el ciclo es solo para Type Hinting (no ejecución real), usa este guardián:
    ```python
    from typing import TYPE_CHECKING
    if TYPE_CHECKING:
        from .grupo import Grupo # Solo lo ve el Linter, no Python
    ```

---

## Buenas Prácticas de Estructura

1.  **Src Layout:** (Visto en Unidad 0.5). Siempre pon tu código en `src/`.
2.  **Un Módulo = Una Responsabilidad:** Si `tils.py` tiene 2000 líneas, está mal.
3.  **Imports Ordenados (isort):**
    1.  StdLib
    2.  Third-Party
    3.  Local
4.  **No usar `from module import *` (Wildcard):**
    Contamina el namespace. Sobreescribe variables sin aviso. Hace imposible saber de dónde viene una función.
    *   *Excepción:* En `__init__.py` para exponer API.


---

## Metaprogramación y Metaclases (El Nivel Dios)

Si las clases son planos para crear objetos, ¿quién crea las clases?
En Python, **todo es un objeto**, incluidas las clases.
Las clases son instancias de una **Metaclase**.

### La Metaclase `type`
Por defecto, todas las clases son creadas por `type`.
```python
# Definición normal
class MiClase:
    x = 1

# Definición dinámica equivalente
MiClase = type('MiClase', (object,), {'x': 1})
```

### Custom Metaclasses
Puedes interceptar la creación de una clase para validarla o modificarla *antes* de que se instancie.
Es útil para:
*   Registrar plugins automáticamente.
*   Validar que la subclase defina ciertos métodos (mejor que ABC en algunos casos).
*   Forzar estándares de nombrado.

```python
class ValidadorMeta(type):
    def __new__(cls, name, bases, dct):
        if 'procesar' not in dct:
            raise TypeError(f"La clase {name} debe tener un método 'procesar'")
        return super().__new__(cls, name, bases, dct)

class Plugin(metaclass=ValidadorMeta):
    def procesar(self):
        pass # Si quito esto, el programa falla al INICIO, no al ejecutar.
```

---

## Abstract Base Classes (ABCs) - Interfaces Estrictas

Python es dinámico (Duck Typing), pero en sistemas grandes necesitas contratos estrictos.
El módulo `abc` formaliza esto.

### `ABC` y `abstractmethod`
```python
from abc import ABC, abstractmethod

class BaseDatabase(ABC):
    @abstractmethod
    def connect(self):
        pass
        
    @abstractmethod
    def query(self, sql: str):
        pass

class MySQLDatabase(BaseDatabase):
    def connect(self):
        print("Conectado")
    # Si olvido implementar 'query', Python IMPIDE instanciar esta clase.
```

### Virtual Subclasses
Puedes registrar una clase como subclase de un ABC sin heredar realmente de ella, siempre que cumpla la interfaz.

---

## Monkey Patching: Magia Negra

Es la técnica de cambiar clases o módulos en **tiempo de ejecución**.
Poderoso pero peligroso.

### Caso de Uso: Testing
Quieres probar una función que borra archivos, pero no quieres borrar archivos reales.
```python
import os
import shutil

# Función a testear
def limpiar_logs():
    shutil.rmtree("/var/log/app")

# El Test
def test_limpiar():
    # Parcheamos rmtree
    original = shutil.rmtree
    shutil.rmtree = lambda path: print(f"Mock: Borrando {path}")
    
    limpiar_logs() # Imprime "Mock...", no borra nada
    
    # Restauramos (CRÍTICO)
    shutil.rmtree = original
```

### Los Peligros
1.  **Confusión:** Si cambias `math.pi = 3`, cualquier otra librería que use pi fallará silenciosamente.
2.  **Guerra de Parches:** Dos librerías intentan parchar la misma función de maneras distintas.

---

## Inyección de Dependencias (Dependency Injection)

Para evitar el acoplamiento fuerte descrito en el punto 1.
En lugar de que `Motor` cree su `Pistón` internamente, se lo pasas desde fuera.

**Acoplado (Mal):**
```python
class Motor:
    def __init__(self):
        self.piston = PistonStandard() # Hardcodeado
```

**Desacoplado (Bien):**
```python
class Motor:
    def __init__(self, piston_instance):
        self.piston = piston_instance # Inyección
```
Esto permite pasar un `PistónDeCarreras` o un `MockPistón` (para tests) sin tocar la clase `Motor`.

---

## Hot Reloading y Carga Dinámica

En sistemas 24/7 (como servidores de telecomunicaciones o juegos), no puedes apagar el servidor para actualizar una función.
Necesitas recargar el módulo en memoria.

### `importlib.reload`
```python
import importlib
import logic_module

def actualizar_logica():
    importlib.reload(logic_module)
    # A partir de aquí, se usa la nueva versión del código
```

**Limitaciones:**
*   Las instancias viejas (variables ya creadas con la clase vieja) NO se actualizan. Seguirán usando la lógica vieja.
*   Solo el código nuevo usará la clase nueva.
*   Esto puede llevar a errores de tipo: `isinstance(obj_viejo, ClaseNueva)` devuelve `False`.

---


---

## Deep Dive: Anatomía de `PyObject` y el Importador en C

Para entender realmente qué es un módulo, debemos bajar al nivel de C (CPython).

### `PyModuleObject`
En el código fuente de CPython (`Objects/moduleobject.c`), un módulo es una estructura:
```c
typedef struct {
    PyObject_HEAD
    PyObject *md_dict;  // El diccionario __dict__ que contiene las variables
    struct PyModuleDef *md_def;
    void *md_state;
} PyModuleObject;
```
Cuando haces `import math`, CPython:
1.  Busca `math.cpython-310.so` (Linux) o `math.pyd` (Windows).
2.  Carga la librería dinámica en RAM (dlopen/LoadLibrary).
3.  Llama a la función de inicialización `PyInit_math`.
4.  Crea la estructura `PyModuleObject`.
5.  La guarda en `sys.modules["math"]`.

### El Diccionario del Módulo (`__dict__`)
Todo módulo es, en esencia, un wrapper alrededor de un diccionario.
```python
import math
# Esto:
math.sqrt(4)
# Es internamente equivalente a:
math.__dict__['sqrt'](4)
```
Por eso la búsqueda de atributos en módulos es O(1) (tiempo constante), porque es una búsqueda en Hash Map.


---

## Internals: La Vida Secreta de los Enteros (`int`)

En C, un `int` son 32 o 64 bits. Si superas 2,147,483,647, hay Overflow.
En Python: 
```python
x = 2 ** 1000 
# Resultado: 1071508607186267320... (funciona perfecto)
```
¿Cómo es posible?

### Arbitrary Precision Integers (BigInt)
En CPython, `int` no es un tipo primitivo. Es un `PyObject` completo que contiene un array de dígitos (`ob_digit`).
Es como si hicieras la suma manualmente en papel (llevando el acarreo), pero en base $2^{30}$.

**Estructura C Real:**
```c
struct _longobject {
    PyObject_VAR_HEAD
    digit ob_digit[1]; // Array dinámico
};
```
Cuando el número crece, Python hace `realloc` y agranda el array.
*   **Costo:** Sumar `int` en Python es O(N) (donde N es el número de bits), mientras que en C es O(1) (si cabe en CPU).
*   **Small Int Cache:** Para no crear objetos locamente, Python pre-crea los enteros del -5 al 256 al arrancar. Son Singletons. `a=10` y `b=10` apuntan a la misma dirección de memoria física.

---

## Gestión de Memoria: Reference Counting

Python no usa `malloc/free` manual. Usa conteo de referencias.
Cada `PyObject` tiene un campo `ob_refcnt`.

1.  `a = [1, 2]` -> refcnt = 1.
2.  `b = a` -> refcnt = 2.
3.  `del a` -> refcnt = 1.
4.  `b = None` -> refcnt = 0 -> **Garbage Collector libera la memoria inmediatamente.**

**El Problema de los Ciclos:**
Si A referencia a B, y B referencia a A, el refcnt nunca baja a 0, aunque nadie más los use. (Memory Leak).
**Solución:** Python tiene un "Cyclic Garbage Collector" (Generacional) que corre periódicamente, pausa el mundo, escanea el grafo de objetos buscando islas aisladas y las mata.

---


---

## Python 3.12+ e Inmortalidad de Objetos

En versiones antiguas, hasta el objeto `None` y `True` tenían un contador de referencias que subía y bajaba millones de veces (`refcnt++`, `refcnt--`). Esto causaba "Cache Invalidation" en CPUs multicore, degradando el rendimiento.

Desde Python 3.12, existen los **Immortal Objects**.
Objetos como `None`, `True`, `False` y pequeños enteros tienen un bit especial que le dice al GC: "Nunca me toques".
*   **Ventaja:** Mejora masiva en performance multihilo y fork().
*   **Internals:** Su `refcnt` se fija en un valor absurdo (como `0xFFFFFFFF`) que nunca cambia.

### Impacto en Copy-On-Write (COW)
En Linux, cuando haces `fork()`, el proceso hijo comparte la RAM del padre hasta que escribe algo.
Antes, al solo *leer* un objeto (ej. `if True:`), el `refcnt` cambiaba, forzando a copiar la página de memoria (COW).
Ahora, como el `refcnt` no cambia, la memoria se mantiene compartida. Reduce el consumo de RAM en servidores como Gunicorn/uWSGI hasta un 30%.

---

## Guía de Optimización de Memoria (Profiling)

¿Tu script consume 8GB de RAM? No adivines. Mide.

### Tracemalloc
Librería estándar para rastrear allocaciones.
```python
import tracemalloc

tracemalloc.start()

# Tu código aquí...
crear_millon_de_objetos()

snapshot = tracemalloc.take_snapshot()
top_stats = snapshot.statistics('lineno')

print("[ Top 10 ]")
for stat in top_stats[:10]:
    print(stat)
```
Te dirá exactamente: "Línea 45 de `main.py` creó 50MB".

### Slots vs Dict (Benchmark Real)
Probemos la diferencia real de `__slots__` (Visto en 2.3 pero profundizado aquí).

```python
import sys
from pympler import asizeof # pip install pympler

class Normal:
    def __init__(self): self.x = 1

class Slotted:
    __slots__ = ['x']
    def __init__(self): self.x = 1

n = Normal()
s = Slotted()

print(f"Dict Size: {asizeof.asizeof(n)} bytes")   # ~152 bytes
print(f"Slot Size: {asizeof.asizeof(s)} bytes")   # ~48 bytes
```
**Regla:** Si vas a crear más de 10,000 instancias de una clase, USA SLOTS.

---

## El Futuro: Python sin GIL (PEP 703)

La comunidad aprobó remover el GIL (Global Interpreter Lock) para Python 3.13+ (opcional).
Esto convierte a Python en un lenguaje verdaderamente **Multihilo Paralelo**, como Java o C++.
*   **Reto:** Todas las librerías C (numpy, pandas) deben reescribirse para proteger su propia memoria, ya que el GIL ya no las cuidará.
*   **Meta:** Para 2028, Python será Thread-Safe sin GIL por defecto.

---

## Anti-Patrones Comunes en Módulos

Errores que delatan a un junior:

### El "God Object"
Un archivo `logica.py` de 5000 líneas.
**Solución:** Separar por dominios (`auth.py`, `billing.py`, `reports.py`).

### Importaciones Circulares Dinámicas
Hacer imports dentro de funciones para evitar errores circulares es un "Code Smell".
Indica que tus módulos están mal diseñados y demasiado acoplados. Extrae la lógica común a un tercer módulo.

### `from x import *`
Nunca. Jamás.
*   No sabes qué nombres estás trayendo.
*   Rompes herramientas estáticas (linters).
*   Si el módulo `x` añade una función `open` en el futuro, sobrescribirá el `open()` nativo de Python y romperá tu código silenciosamente.

---

## Laboratorio Avanzado: Introspección Profunda

Crear un script `inspector.py` que reciba el nombre de cualquier módulo y reporte:
1.  Cuántas Clases tiene.
2.  Cuántas Funciones.
3.  Jerarquía de herencia de cada clase (MRO).
4.  Rutas de archivo físicas.

Usa el módulo `inspect` y `pkgutil`.

```python
import inspect
import importlib

def auditar(modulo_str):
    mod = importlib.import_module(modulo_str)
    print(f"Auditando: {mod.__name__} ({mod.__file__})")
    
    for name, obj in inspect.getmembers(mod):
        if inspect.isclass(obj):
            print(f"Clase: {name} -> Herencia: {inspect.getmro(obj)}")
        elif inspect.isfunction(obj):
            print(f"Función: {name}")

auditar("json")
```

---


---

## Metaprogramación y Metaclases (El Nivel Dios)

Si las clases son planos para crear objetos, ¿quién crea las clases?
En Python, **todo es un objeto**, incluidas las clases.
Las clases son instancias de una **Metaclase**.

### La Metaclase `type`
Por defecto, todas las clases son creadas por `type`.
```python
# Definición normal
class MiClase:
    x = 1

# Definición dinámica equivalente
MiClase = type('MiClase', (object,), {'x': 1})
```

### Custom Metaclasses
Puedes interceptar la creación de una clase para validarla o modificarla *antes* de que se instancie.
Es útil para:
*   Registrar plugins automáticamente.
*   Validar que la subclase defina ciertos métodos (mejor que ABC en algunos casos).
*   Forzar estándares de nombrado.

```python
class ValidadorMeta(type):
    def __new__(cls, name, bases, dct):
        if 'procesar' not in dct:
            raise TypeError(f"La clase {name} debe tener un método 'procesar'")
        return super().__new__(cls, name, bases, dct)

class Plugin(metaclass=ValidadorMeta):
    def procesar(self):
        pass # Si quito esto, el programa falla al INICIO, no al ejecutar.
```

---

## Abstract Base Classes (ABCs) - Interfaces Estrictas

Python es dinámico (Duck Typing), pero en sistemas grandes necesitas contratos estrictos.
El módulo `abc` formaliza esto.

### `ABC` y `abstractmethod`
```python
from abc import ABC, abstractmethod

class BaseDatabase(ABC):
    @abstractmethod
    def connect(self):
        pass
        
    @abstractmethod
    def query(self, sql: str):
        pass

class MySQLDatabase(BaseDatabase):
    def connect(self):
        print("Conectado")
    # Si olvido implementar 'query', Python IMPIDE instanciar esta clase.
```

### Virtual Subclasses
Puedes registrar una clase como subclase de un ABC sin heredar realmente de ella, siempre que cumpla la interfaz.

---

## Monkey Patching: Magia Negra

Es la técnica de cambiar clases o módulos en **tiempo de ejecución**.
Poderoso pero peligroso.

### Caso de Uso: Testing
Quieres probar una función que borra archivos, pero no quieres borrar archivos reales.
```python
import os
import shutil

# Función a testear
def limpiar_logs():
    shutil.rmtree("/var/log/app")

# El Test
def test_limpiar():
    # Parcheamos rmtree
    original = shutil.rmtree
    shutil.rmtree = lambda path: print(f"Mock: Borrando {path}")
    
    limpiar_logs() # Imprime "Mock...", no borra nada
    
    # Restauramos (CRÍTICO)
    shutil.rmtree = original
```

### Los Peligros
1.  **Confusión:** Si cambias `math.pi = 3`, cualquier otra librería que use pi fallará silenciosamente.
2.  **Guerra de Parches:** Dos librerías intentan parchar la misma función de maneras distintas.

---

## Inyección de Dependencias (Dependency Injection)

Para evitar el acoplamiento fuerte descrito en el punto 1.
En lugar de que `Motor` cree su `Pistón` internamente, se lo pasas desde fuera.

**Acoplado (Mal):**
```python
class Motor:
    def __init__(self):
        self.piston = PistonStandard() # Hardcodeado
```

**Desacoplado (Bien):**
```python
class Motor:
    def __init__(self, piston_instance):
        self.piston = piston_instance # Inyección
```
Esto permite pasar un `PistónDeCarreras` o un `MockPistón` (para tests) sin tocar la clase `Motor`.

---

## Hot Reloading y Carga Dinámica

En sistemas 24/7 (como servidores de telecomunicaciones o juegos), no puedes apagar el servidor para actualizar una función.
Necesitas recargar el módulo en memoria.

### `importlib.reload`
```python
import importlib
import logic_module

def actualizar_logica():
    importlib.reload(logic_module)
    # A partir de aquí, se usa la nueva versión del código
```

**Limitaciones:**
*   Las instancias viejas (variables ya creadas con la clase vieja) NO se actualizan. Seguirán usando la lógica vieja.
*   Solo el código nuevo usará la clase nueva.
*   Esto puede llevar a errores de tipo: `isinstance(obj_viejo, ClaseNueva)` devuelve `False`.

---


---

## Deep Dive: Anatomía de `PyObject` y el Importador en C

Para entender realmente qué es un módulo, debemos bajar al nivel de C (CPython).

### `PyModuleObject`
En el código fuente de CPython (`Objects/moduleobject.c`), un módulo es una estructura:
```c
typedef struct {
    PyObject_HEAD
    PyObject *md_dict;  // El diccionario __dict__ que contiene las variables
    struct PyModuleDef *md_def;
    void *md_state;
} PyModuleObject;
```
Cuando haces `import math`, CPython:
1.  Busca `math.cpython-310.so` (Linux) o `math.pyd` (Windows).
2.  Carga la librería dinámica en RAM (dlopen/LoadLibrary).
3.  Llama a la función de inicialización `PyInit_math`.
4.  Crea la estructura `PyModuleObject`.
5.  La guarda en `sys.modules["math"]`.

### El Diccionario del Módulo (`__dict__`)
Todo módulo es, en esencia, un wrapper alrededor de un diccionario.
```python
import math
# Esto:
math.sqrt(4)
# Es internamente equivalente a:
math.__dict__['sqrt'](4)
```
Por eso la búsqueda de atributos en módulos es O(1) (tiempo constante), porque es una búsqueda en Hash Map.


---

## Internals: La Vida Secreta de los Enteros (`int`)

En C, un `int` son 32 o 64 bits. Si superas 2,147,483,647, hay Overflow.
En Python: 
```python
x = 2 ** 1000 
# Resultado: 1071508607186267320... (funciona perfecto)
```
¿Cómo es posible?

### Arbitrary Precision Integers (BigInt)
En CPython, `int` no es un tipo primitivo. Es un `PyObject` completo que contiene un array de dígitos (`ob_digit`).
Es como si hicieras la suma manualmente en papel (llevando el acarreo), pero en base $2^{30}$.

**Estructura C Real:**
```c
struct _longobject {
    PyObject_VAR_HEAD
    digit ob_digit[1]; // Array dinámico
};
```
Cuando el número crece, Python hace `realloc` y agranda el array.
*   **Costo:** Sumar `int` en Python es O(N) (donde N es el número de bits), mientras que en C es O(1) (si cabe en CPU).
*   **Small Int Cache:** Para no crear objetos locamente, Python pre-crea los enteros del -5 al 256 al arrancar. Son Singletons. `a=10` y `b=10` apuntan a la misma dirección de memoria física.

---

## Gestión de Memoria: Reference Counting

Python no usa `malloc/free` manual. Usa conteo de referencias.
Cada `PyObject` tiene un campo `ob_refcnt`.

1.  `a = [1, 2]` -> refcnt = 1.
2.  `b = a` -> refcnt = 2.
3.  `del a` -> refcnt = 1.
4.  `b = None` -> refcnt = 0 -> **Garbage Collector libera la memoria inmediatamente.**

**El Problema del Multihilo:**
Si A referencia a B, y B referencia a A, el refcnt nunca baja a 0, aunque nadie más los use. (Memory Leak).
**Solución:** Python tiene un "Cyclic Garbage Collector" (Generacional) que corre periódicamente, pausa el mundo, escanea el grafo de objetos buscando islas aisladas y las mata.

---


---

## Python 3.12+ e Inmortalidad de Objetos

En versiones antiguas, hasta el objeto `None` y `True` tenían un contador de referencias que subía y bajaba millones de veces (`refcnt++`, `refcnt--`). Esto causaba "Cache Invalidation" en CPUs multicore, degradando el rendimiento.

Desde Python 3.12, existen los **Immortal Objects**.
Objetos como `None`, `True`, `False` y pequeños enteros tienen un bit especial que le dice al GC: "Nunca me toques".
*   **Ventaja:** Mejora masiva en performance multihilo y fork().
*   **Internals:** Su `refcnt` se fija en un valor absurdo (como `0xFFFFFFFF`) que nunca cambia.

### Impacto en Copy-On-Write (COW)
En Linux, cuando haces `fork()`, el proceso hijo comparte la RAM del padre hasta que escribe algo.
Antes, al solo *leer* un objeto (ej. `if True:`), el `refcnt` cambiaba, forzando a copiar la página de memoria (COW).
Ahora, como el `refcnt` no cambia, la memoria se mantiene compartida. Reduce el consumo de RAM en servidores como Gunicorn/uWSGI hasta un 30%.

---

## Guía de Optimización de Memoria (Profiling)

¿Tu script consume 8GB de RAM? No adivines. Mide.

### Tracemalloc
Librería estándar para rastrear allocaciones.
```python
import tracemalloc

tracemalloc.start()

# Tu código aquí...
crear_millon_de_objetos()

snapshot = tracemalloc.take_snapshot()
top_stats = snapshot.statistics('lineno')

print("[ Top 10 ]")
for stat in top_stats[:10]:
    print(stat)
```
Te dirá exactamente: "Línea 45 de `main.py` creó 50MB".

### Slots vs Dict (Benchmark Real)
Probemos la diferencia real de `__slots__` (Visto en 2.3 pero profundizado aquí).

```python
import sys
from pympler import asizeof # pip install pympler

class Normal:
    def __init__(self): self.x = 1

class Slotted:
    __slots__ = ['x']
    def __init__(self): self.x = 1

n = Normal()
s = Slotted()

print(f"Dict Size: {asizeof.asizeof(n)} bytes")   # ~152 bytes
print(f"Slot Size: {asizeof.asizeof(s)} bytes")   # ~48 bytes
```
**Regla:** Si vas a crear más de 10,000 instancias de una clase, USA SLOTS.

---

## El Futuro: Python sin GIL (PEP 703)

La comunidad aprobó remover el GIL (Global Interpreter Lock) para Python 3.13+ (opcional).
Esto convierte a Python en un lenguaje verdaderamente **Multihilo Paralelo**, como Java o C++.
*   **Reto:** Todas las librerías C (numpy, pandas) deben reescribirse para proteger su propia memoria, ya que el GIL ya no las cuidará.
*   **Meta:** Para 2028, Python será Thread-Safe sin GIL por defecto.

---

## Anti-Patrones Comunes en Módulos

Errores que delatan a un junior:

### El "God Object"
Un archivo `logica.py` de 5000 líneas.
**Solución:** Separar por dominios (`auth.py`, `billing.py`, `reports.py`).

### Importaciones Circulares Dinámicas
Hacer imports dentro de funciones para evitar errores circulares es un "Code Smell".
Indica que tus módulos están mal diseñados y demasiado acoplados. Extrae la lógica común a un tercer módulo.

### `from x import *`
Nunca. Jamás.
*   No sabes qué nombres estás trayendo.
*   Rompes herramientas estáticas (linters).
*   Si el módulo `x` añade una función `open` en el futuro, sobrescribirá el `open()` nativo de Python y romperá tu código silenciosamente.

---

## Laboratorio Avanzado: Introspección Profunda

Crear un script `inspector.py` que reciba el nombre de cualquier módulo y reporte:
1.  Cuántas Clases tiene.
2.  Cuántas Funciones.
3.  Jerarquía de herencia de cada clase (MRO).
4.  Rutas de archivo físicas.

Usa el módulo `inspect` y `pkgutil`.

```python
import inspect
import importlib

def auditar(modulo_str):
    mod = importlib.import_module(modulo_str)
    print(f"Auditando: {mod.__name__} ({mod.__file__})")
    
    for name, obj in inspect.getmembers(mod):
        if inspect.isclass(obj):
            print(f"Clase: {name} -> Herencia: {inspect.getmro(obj)}")
        elif inspect.isfunction(obj):
            print(f"Función: {name}")

auditar("json")
```

---

<div align="center">

[⬅️ Anterior: Unidad 1](../unidad1/README.md) &nbsp;&nbsp;|&nbsp;&nbsp; [Menú Unidad](README.md) &nbsp;&nbsp;|&nbsp;&nbsp; [Siguiente: 2.2 Librería Estándar](2.2.md) ➡️

</div>
