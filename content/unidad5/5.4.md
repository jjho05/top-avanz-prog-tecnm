# 5.4 Desarrollo de aplicaciones móviles (Flet Framework)

## La Revolución de Flutter en Python

**Flet** es un wrapper de Python alrededor del motor de **Flutter** (Google).
Flutter revolucionó el desarrollo móvil porque no usa los widgets nativos (que son difíciles de unificar entre iOS/Android), sino que dibuja su propia interfaz usando **Skia** (el mismo motor gráfico de Chrome).

Flet nos permite escribir controles de Flutter pero usando Python puro.
Arquitectura:
`Python Script -> Flet Server (Local) -> Flutter Client App`

---

## Estructura de una App Flet

Todo comienza con una `Page` (la ventana o pantalla del móvil).

```python
import flet as ft

def main(page: ft.Page):
    # Configuración de página
    page.title = "TecNM App"
    page.theme_mode = ft.ThemeMode.LIGHT
    page.padding = 20
    
    # Agregar controles
    texto = ft.Text(value="Hola Flet!", size=30, color="blue")
    page.add(texto)

ft.app(target=main)
```

### Modelo Reactivo
Flet funciona por **Estado**.
1.  Creas controles.
2.  Los modificas (`texto.value = "Chao"`).
3.  Llamas a `page.update()` (o `control.update()`).
4.  Flet envía solo el "delta" (los cambios) a la pantalla.

---

## Controles Fundamentales

Flet tiene cientos de controles. Aquí los esenciales.

### A. Layouts (Filas y Columnas)
Equivalente a Flexbox en CSS.
*   `Row`: Horizontal. `controls=[...]`.
*   `Column`: Vertical. `scroll=ft.ScrollMode.AUTO` si el contenido es largo.

### B. Inputs
*   `TextField`: Texto. `password=True`, `keyboard_type=ft.KeyboardType.EMAIL`.
*   `ElevatedButton`: El botón estándar Material.
*   `FloatingActionButton (FAB)`: El botón redondo flotante clásico de Android.

### C. Navegación
*   `AppBar`: Barra superior azul.
*   `NavigationBar`: Barra inferior con iconos (Home, Search, Profile).

---

## Routing (Navegación entre Pantallas)

Una App real tiene múltiples vistas. Flet maneja esto cambiando la URL virtual (route).

```python
def main(page: ft.Page):
    
    def route_change(route):
        page.views.clear()
        
        # Vista Home (/)
        page.views.append(
            ft.View(
                "/",
                [
                    ft.AppBar(title=ft.Text("Home"), bgcolor=ft.colors.SURFACE_VARIANT),
                    ft.ElevatedButton("Ir a Ajustes", on_click=lambda _: page.go("/settings")),
                ],
            )
        )
        
        # Vista Settings
        if page.route == "/settings":
            page.views.append(
                ft.View(
                    "/settings",
                    [
                        ft.AppBar(title=ft.Text("Ajustes")),
                        ft.Text("Configuración..."),
                        ft.ElevatedButton("Volver", on_click=lambda _: page.go("/")),
                    ],
                )
            )
        page.update()

    def view_pop(view):
        page.views.pop()
        top_view = page.views[-1]
        page.go(top_view.route)

    page.on_route_change = route_change
    page.on_view_pop = view_pop # Botón "Atrás" de Android
    page.go(page.route)
```
Este sistema soporte el botón "Atrás" físico de Android nativamente (`view_pop`).

---

## Deployment: De Python a APK

Aquí es donde ocurre la magia. Usaremos el comando `flet build`.
Requisitos: Tener instalado el **Flutter SDK** en tu máquina (es pesado, ~1GB).

### Proceso de Compilación
1.  **Iconos:** Prepara un `icon.png`.
2.  **Comando:**
    ```bash
    flet build apk
    ```
    Este comando hace todo:
    *   Crea un proyecto Flutter andamio.
    *   Empaqueta tu código Python.
    *   Descarga el intérprete Python ARM.
    *   Compila todo en `build/app/outputs/flutter-apk/app-release.apk`.

### Probando en iPhone (Limitación)
Para compilar IPA (iOS), **necesitas una Mac**. Flet no puede crear apps de iOS desde Windows. Sin embargo, puedes usar la app "Flet" de la App Store para probar tu código hosteado en tu PC via red local.

---

## Accesso a Sensores (Client Storage)

Flet permite usar el almacenamiento seguro del dispositivo (Keychain/SharedPrefs).

```python
# Guardar Token
page.client_storage.set("auth_token", "abc-123")

# Leer
token = page.client_storage.get("auth_token")

# Verificar si existe
if page.client_storage.contains_key("auth_token"):
    ...
```

Para sensores más complejos (Cámara, GPS), Flet está agregando soporte gradualmente o debes usar plugins. Actualmente, funciones como Geolocalización están disponibles mediante `flet.geolocator`.

---

## Responsive Design (Adaptive)

Tu App debe verse bien en un Pixel 7 y en un iPad Pro.

```python
class ResponsiveCard(ft.Container):
    def did_mount(self):
        self.page.on_resize = self.on_resize
        self.on_resize()
        
    def on_resize(self, e=None):
        if self.page.width > 600:
            # Modo Tablet/Desktop
            self.content = ft.Row([...])
        else:
            # Modo Móvil
            self.content = ft.Column([...])
        self.update()
```

---

## Laboratorio 5.4: To-Do List Conectada

Proyecto Fin de Unidad.
1.  **VBC (View-Based Class):** Cada pantalla será una clase.
2.  **Estado:** Lista de tareas en memoria.
3.  **UI:**
    *   `TextField` para nueva tarea + `IconButton` (Add).
    *   `ListView` con `Checkbox` y Texto.
    *   Deslizar para borrar (`Dismissible`).
4.  **Compilación:** Generar el APK e instalarlo en un dispositivo real.


---

## Publicando en Google Play Store

No puedes subir un APK crudo hoy en día.
Google exige **AAB (Android App Bundle)**.

1.  **Firma Digital (Keystore):**
    Necesitas generar una llave criptográfica única. Si la pierdes, **PIERDES TU APP PARA SIEMPRE**. No podrás actualizarla nunca más.
    ```bash
    keytool -genkey -v -keystore mi-llave.jks -keyalg RSA -keysize 2048 -validity 10000 -alias mi-alias
    ```

2.  **Compilación Release:**
    Flet automatiza esto, pero por debajo usa `flutter build appbundle`.

3.  **Google Play Console:**
    Subes el `.aab`. Google lo re-empaqueta en APKs optimizados para cada arquitectura (ARMv7, ARM64, x86) para que el usuario descargue lo mínimo necesario (Split APKs).

---

## AsyncIO en Flet (Best Practice)

Flet soporta `async` nativamente. Es vital para no congelar la UI.

```python
import asyncio

async def realizar_tarea_larga(e):
    # Sin async, esto congelaría el botón
    lbl_status.value = "Cargando..."
    lbl_status.update()
    
    await asyncio.sleep(2) # Libera el hilo UI
    
    lbl_status.value = "¡Listo!"
    lbl_status.update()

# Nota el 'async' en main
async def main(page: ft.Page):
    btn = ft.ElevatedButton("Procesar", on_click=realizar_tarea_larga)
    page.add(btn)

ft.app(target=main)
```

---

## Hot Reload (Productividad Extrema)

Desarrollar reiniciando la app a cada cambio es lento.
Flet soporta recarga en caliente (como React o Flutter).

Ejecuta en tu terminal:
```bash
flet run main.py -r
```
Ahora, al guardar `main.py` (Ctrl+S), la ventana se actualiza instantáneamente manteniendo el estado (texto escrito, scroll position).

---


---

## Internals: Skia y el "Deferred Rendering"

¿Cómo logra Flet/Flutter 120 FPS?
No dibuja al instante.
1.  **Build Phase:** Python construye el Widget Tree (abstracto).
2.  **Layout Phase:** Flutter calcula tamaños (Constraints: Min/Max Width/Height).
3.  **Paint Phase:** No pinta píxeles. Genera una "Display List" (Lista de comandos vectorial: `drawRect`, `drawText`).
4.  **Rasterization (GPU):** Skia toma la lista y usa OpenGL/Vulkan para convertir vectores a píxeles en la VRAM.

**Deferred Display Lists:**
Si algo no cambia (ej. el fondo), Skia reutiliza la lista de comandos anterior.
Solo repinta lo que cambió (Dirty Region).
Por eso `page.update()` es crucial: le dice al motor qué parte de la lista está "sucia".


---

## Comunicación en Tiempo Real: WebSockets

REST es unidireccional (Cliente pide -> Server responde).
Para un Chat o Uber, necesitas **WebSockets**.
Es un tubo bidireccional abierto permanentemente.

```python
import flet as ft

def main(page: ft.Page):
    # Flet tiene soporte nativo para suscripciones PubSub
    def on_message(msg):
        page.add(ft.Text(f"Recibido: {msg}"))

    page.pubsub.subscribe_topic("chat_general", on_message)

    def enviar(e):
        page.pubsub.send_all_on_topic("chat_general", "Hola Mundo!")
    
    page.add(ft.ElevatedButton("Enviar", on_click=enviar))

ft.app(target=main)
```
Esto funciona "out-of-the-box" en Flet para comunicación entre usuarios de la misma app.

---

## gRPC vs REST en Móvil

Google usa **gRPC** (Protobufs) internamente, no JSON.
*   **JSON (REST):** Texto legible. Pesado. `{"nombre": "Juan"}` son 18 bytes.
*   **Protobuf (gRPC):** Binario comprimido. `Juan` más 2 bytes de cabecera. Total 6 bytes.
*   **Ahorro:** 66% menos datos. En móvil (3G/4G), esto significa carga 3 veces más rápida y menos batería.
*   **Tipado:** Fuertemente tipado. No puedes enviar un String donde va un Int. Genera código cliente automáticamente (`proto_pb2.py`).

Flet soporta gRPC perfectamente porque es Python puro.

---

## NFC (Near Field Communication)

La tecnología detrás de Apple Pay / Google Wallet.
*   **Modo Lectura:** Leer un tag NFC pasivo (etiqueta en un museo).
*   **Modo Escritura:** Programar un tag.
*   **Host Card Emulation (HCE):** Tu celular **finge** ser una tarjeta de crédito para que la terminal de punto de venta lo lea.

En Python, el acceso a NFC es complicado y requiere módulos nativos puenteados. Es una de las pocas áreas donde Java/Kotlin nativo sigue siendo muy superior.

---

## Manejo de Errores UX (Error Boundaries)

Cuando falla una petición HTTP, no muestres un Traceback.
El usuario no sabe qué es un `404 Not Found`.

**Patrones de UX:**
1.  **Toast / SnackBar:** Mensaje efímero abajo. "No hay internet. Reintentando..."
2.  **Banner:** Aviso persistente arriba. "Modo Offline activado".
3.  **Empty State:** Si la lista está vacía por error, muestra una ilustración bonita y un botón "Recargar".
4.  **Skeleton Loading:** Muestra cajas grises brillantes mientras carga, en lugar de un spinner aburrido. Hace que la app se sienta más rápida.

```python
def mostrar_error(page, mensaje):
    page.snack_bar = ft.SnackBar(ft.Text(mensaje), bgcolor="red")
    page.snack_bar.open = True
    page.update()
```

---

## GraphQL: El asesino de REST en Móvil

En REST, tienes `/api/users` y `/api/posts`.
Si quieres "Usuarios con sus Posts", tienes que hacer 2 peticiones (Lento en móvil).
O crear un endpoint específico `/api/users_with_posts` (Espagueti en backend).

**GraphQL** permite al móvil pedir *exactamente* lo que quiere en una sola request:
```graphql
query {
  users {
    nombre
    posts {
      titulo
      likes
    }
  }
}
```
Esto reduce el **Over-fetching** (traer datos que no usas) y **Under-fetching** (tener que hacer N+1 requests).

---

## Estrategias de Caché Local

La mejor petición de red es la que no se hace.
1.  **Memory Cache:** Diccionario en RAM. Se pierde al cerrar la app. Rápido.
2.  **Disk Cache (HTTP):** Cabeceras `Cache-Control` y `ETag`. El sistema guarda las imágenes automáticamente.
3.  **Database Cache (SQLite):** Guardar los JSONs de respuesta en una tabla `cache_responses` con un Timestamp.
    *   Al pedir datos, primero mira la DB local.
    *   Si el dato tiene < 5 minutos, úsalo (Instantáneo).
    *   Si es viejo, ve a la red, actualiza la UI y actualiza la DB.
    *   Llamado patrón **"Stale-While-Revalidate"**.

---


---

## El Motor Gráfico Skia

Flet, Flutter y Chrome comparten el mismo corazón: **Skia**.
Es un motor de renderizado 2D de Google (C++).
Cuando dibujas un botón en Flet, no estás usando un botón de Android ni de Windows.
Skia dibuja píxeles directamente en una textura OpenGL/Vulkan.

**Ventaja:** Tu app se ve IDÉNTICA en Pixel, iPhone, Windows y Web. Pixel Perfect.
**Desventaja:** Pesa más (el APK incluye el motor Skia completo).

---

## Accesibilidad (A11y): El Usuario olvidado

El 15% de la población tiene alguna discapacidad.
En Android, el servicio **TalkBack** lee la pantalla para ciegos.
Si dibujas un botón custom con Skia/Canvas, TalkBack no sabe qué es.
Debes agregar **Semántica**.

```python
# En Flet
container = ft.Container(
    content=ft.Text("Enviar"),
    semantics_label="Botón para enviar formulario", # Lo que lee TalkBack
    on_click=enviar
)
```
Sin esto, tu app es inutilizable para millones de personas (y es ilegal en contratos de gobierno).

---

## Diseño Háptico (Haptic Feedback)

No solo visual y auditivo. El tacto importa.
Los celulares modernos tienen motores de vibración lineal (Taptic Engine).
No uses `vibrate(1000)` (vibración bruta). Usa la API háptica.

*   **ImpactLight:** Vibración sutil al hacer scroll en una lista de fechas (tipo caja fuerte).
*   **Success:** Doble golpecito al completar una tarea.
*   **Error:** Sacudida fuerte.

En Flet/Python esto se accede mediante `flet.haptic_feedback` (depende del soporte del dispositivo).

---

## Material Design 3 (Material You)

Google cambió las reglas en Android 12.
Ahora el color de la App se adapta al **Fondo de Pantalla del Usuario**.
Si el usuario tiene un fondo de bosque, los botones de tu app deberían ser verdes pastel.
Flet soporta esto nativamente con `theme_mode=ft.ThemeMode.SYSTEM` y `use_material3=True`.
Ignorar esto hace que tu app se sienta "vieja" en celulares nuevos.


## Inyección de Dependencias: Dagger & Hilt

En apps grandes, pasar objetos `Database` o `Retrofit` por el constructor de 40 clases es horrible.
**Hilt** (basado en Dagger 2) genera código en tiempo de compilación.
Tú anotas `@Inject` y `@Singleton`.
Hilt crea el grafo de dependencias y te da el objeto listo.

En Python/Flet no es tan común, pero patrones como "Service Locator" o librerías como `DependencyInjector` logran lo mismo.

---

## Retrofit: Magia con Dynamic Proxies

¿Cómo funciona Retrofit?
Define una interfaz:
```java
interface Api { @GET("users") Call<User> getUsers(); }
```
Retrofit usa `Proxy.newProxyInstance()` para interceptar las llamadas a esa interfaz en tiempo de ejecución, lee las anotaciones, construye el HTTP Request, lo envía con OkHttp, y parsea la respuesta con Gson.
Es metaprogramación pura.

---

## Room: Abstracción de SQLite

SQLiteNatido requiere escribir mucho boilerplate (Cursores, valores de columnas).
**Room** es una capa que verifica tus queries SQL en tiempo de compilación.
Si escribes `SELECT * FORM users` (error de dedo), tu app no compila.
Además, devuelve objetos `Flow` o `LiveData` que notifican a la UI automáticamente cuando la DB cambia.

---

## Carga de Imágenes: Glide/Coil

Cargar una imagen de internet es difícil:
1.  Bajar bytes.
2.  Decodificar JPG a Bitmap (usa mucha RAM).
3.  Escalar a tamaño del ImageView (Downsampling) para no explotar memoria.
4.  Caché en disco y memoria.
5.  Reciclaje de Bitmaps en listas (ListView).

Librerías como **Coil** (Coroutines Image Loader) manejan todo esto. Nunca uses `BitmapFactory.decodeStream` directo en el Main Thread.


## Profundización Técnica: Librerías de Jetpack

En este capítulo, vamos a desglosar Librerías de Jetpack átomo por átomo.
La ingeniería de software moderna requiere un entendimiento profundo de estos conceptos.

### Concepto Clave: Room, Retrofit, y Navigation - Parte 1
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Room, Retrofit, y Navigation, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_1():
    # Implementación de Librerías de Jetpack variante 1
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 1:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Room, Retrofit, y Navigation - Parte 2
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Room, Retrofit, y Navigation, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_2():
    # Implementación de Librerías de Jetpack variante 2
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 2:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Room, Retrofit, y Navigation - Parte 3
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Room, Retrofit, y Navigation, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_3():
    # Implementación de Librerías de Jetpack variante 3
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 3:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Room, Retrofit, y Navigation - Parte 4
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Room, Retrofit, y Navigation, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_4():
    # Implementación de Librerías de Jetpack variante 4
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 4:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Room, Retrofit, y Navigation - Parte 5
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Room, Retrofit, y Navigation, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_5():
    # Implementación de Librerías de Jetpack variante 5
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 5:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Room, Retrofit, y Navigation - Parte 6
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Room, Retrofit, y Navigation, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_6():
    # Implementación de Librerías de Jetpack variante 6
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 6:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Room, Retrofit, y Navigation - Parte 7
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Room, Retrofit, y Navigation, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_7():
    # Implementación de Librerías de Jetpack variante 7
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 7:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Room, Retrofit, y Navigation - Parte 8
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Room, Retrofit, y Navigation, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_8():
    # Implementación de Librerías de Jetpack variante 8
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 8:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Room, Retrofit, y Navigation - Parte 9
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Room, Retrofit, y Navigation, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_9():
    # Implementación de Librerías de Jetpack variante 9
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 9:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Room, Retrofit, y Navigation - Parte 10
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Room, Retrofit, y Navigation, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_10():
    # Implementación de Librerías de Jetpack variante 10
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 10:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Room, Retrofit, y Navigation - Parte 11
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Room, Retrofit, y Navigation, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_11():
    # Implementación de Librerías de Jetpack variante 11
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 11:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Room, Retrofit, y Navigation - Parte 12
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Room, Retrofit, y Navigation, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_12():
    # Implementación de Librerías de Jetpack variante 12
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 12:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Room, Retrofit, y Navigation - Parte 13
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Room, Retrofit, y Navigation, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_13():
    # Implementación de Librerías de Jetpack variante 13
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 13:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Room, Retrofit, y Navigation - Parte 14
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Room, Retrofit, y Navigation, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_14():
    # Implementación de Librerías de Jetpack variante 14
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 14:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Room, Retrofit, y Navigation - Parte 15
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Room, Retrofit, y Navigation, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_15():
    # Implementación de Librerías de Jetpack variante 15
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 15:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.



<div align="center">

[⬅️ Anterior: 5.3 Ambiente Móvil](5.3.md) &nbsp;&nbsp;|&nbsp;&nbsp; [Menú Unidad](README.md) &nbsp;&nbsp;|&nbsp;&nbsp; [Siguiente: 5.5 Seguridad Móvil](5.5.md) ➡️

</div>
