# 5.5 Seguridad en dispositivos móviles (OWASP Mobile Top 10)

## El Móvil es Territorio Hostil

En un servidor web, tú controlas el entorno físico (Data Center, Firewall).
En una App Móvil, **tu código corre en el dispositivo del atacante**.
El usuario tiene acceso físico total. Puede conectar el teléfono por USB, hacer Root/Jailbreak, leer la memoria RAM, interceptar el WiFi y descompilar tu APK.

Asume siempre que **tu App está comprometida**.

---

## Ingeniería Inversa (Reverse Engineering)

Cualquier APK se puede abrir. Es un simple ZIP.
Herramientas como `JADX` o `APKTool` permiten ver el código Java y, en el caso de aplicaciones Python (Kivy/Flet), es aún más fácil:
1.  Descomprimir APK.
2.  Ir a `assets/private.mp3` (o similar, donde se empacan los assets).
3.  Extraer el código fuente `.py` o `.pyc`.

**Contramedida: Ofuscación**
No puedes evitar 100% que lean tu código, pero puedes hacerlo difícil.
*   Compilar a `.pyc` (Bytecode) ayuda un poco.
*   Usar **Cython**: Convierte tu Python a C y compílalo a binario `.so`. Es mucho más difícil de leer para humanos que el bytecode.

**REGLA DE ORO:** Jamás hardcodees API Keys, Passwords de BD o Secretos de AWS en el código fuente (`const SECRET = "..."`). Un hacker lo encontrará en 5 minutos con `grep`.

---

## Comunicación Segura (HTTP vs HTTPS)

El ataque Man-In-The-Middle (MITM).
Si usas `http://`, cualquiera en el WiFi de Starbucks puede leer los datos (usuario/pass) con Wireshark.

### Certificate Pinning
Incluso con `https://`, un atacante puede instalar un certificado raíz falso en su propio teléfono para inspeccionar el tráfico cifrado (usando Charles Proxy).
El **Certificate Pinning** es una técnica donde tu App rechaza cualquier certificado SSL que no sea EXACTAMENTE el de tu servidor (comparando el Hash de la llave pública), ignorando los certificados del sistema del usuario.

En Python `requests`:
```python
# Verificar fingerprint del certificado
# (Es una implementación compleja, usualmente se hace a nivel de config de red de Android)
```

---

## Almacenamiento Inseguro de Datos

¿Dónde guardas el token de sesión "Remember Me"?

*   **Mal:** `SharedPreferences` en texto plano o archivo JSON en SD Card. Malware con permiso de leer storage puede robarlo.
*   **Bien:** Usar el **Keystore/Keychain** del sistema. Es un chip de hardware seguro (TEE - Trusted Execution Environment) que encripta los datos y solo tu App (identificada por su firma criptográfica) puede desencriptarlos.
    *   En Flet: `page.client_storage` es conveniente pero verifica si usa Encriptación en la implementación subyacente (SecureStorage).

### Datos en Caché
Cuidado con lo que el teclado guarda en caché (texto predictivo), capturas de pantalla automáticas del Task Switcher (Android saca foto de tu app al minimizarla para la animación).
*   Solución: Marcar campos de password como `FLAG_SECURE` (Impide screenshots).

---

## OWASP Mobile Top 10

La biblia de la seguridad móvil.
1.  **M1: Uso Impropio de Credenciales:** Hardcodear claves.
2.  **M2: Seguridad en la Cadena de Suministro:** Usar una librería `pip` maliciosa que roba datos.
3.  **M3: Autenticación Insegura:** Permitir pines de 4 dígitos para transferencias millonarias.
4.  **M4: Comunicación Insegura:** HTTP o SSL mal configurado.
5.  **M5: Autorización Inadecuada:** El servidor confía ciegamente en lo que dice el móvil ("Soy admin"). El servidor siempre debe validar.

---

## Permisos Mínimos (Least Privilege)

No pidas permiso de **Cámara** si solo vas a subir una foto de perfil (usa el selector de galería del sistema).
No pidas **Ubicación Precisa (GPS)** si solo necesitas saber la Ciudad (Ubicación Aproximada).
Cuantos menos permisos pidas:
1.  Más seguro es para el usuario.
2.  Más confianza generas.
3.  Menos vectores de ataque tienes.

---

## Prácticas de Cierre

La seguridad no es un "Feature" que se agrega al final. Es un proceso.
Para aplicaciones Python móviles:
1.  Minimizar lógica sensible en el lado del cliente (Móvil). Moverla al Servidor.
2.  El móvil debe ser una terminal "tonta" que solo muestra datos y envía comandos.
3.  Usar OAuth2/OIDC para autenticación en lugar de manejar passwords directamente si es posible.

**Conclusión Final del Curso:**
Hemos recorrido desde el átomo de Python (Entornos Virtuales) hasta la complejidad del desarrollo móvil seguro, pasando por GUIs Desktop, Concurrencia y Bases de Datos.
Ahora tienes las herramientas de un **Full Stack Python Developer**. Lo que construyas con ellas depende de ti.


---

## Internals: Secure Enclave (iOS) y Titan M (Android)

La seguridad moderna no es software. Es hardware.
Los iPhones tienen un coprocesador llamado **Secure Enclave**.
*   Tiene su propia RAM encriptada.
*   Tiene su propio Kernel (SepOS).
*   El procesador principal (A16 Bionic) **NO PUEDE LEER** la memoria del Enclave.

Cuando usas FaceID o guardas un Password en Keychain:
1.  El CPU principal envía los bytes encriptados al Enclave.
2.  El Enclave los desencripta con una llave **física** fundida en el silicio (UID).
3.  Verifica el FaceID (que también vive en el Enclave).
4.  Devuelve "Acceso Concedido" o "Denegado", pero **NUNCA** devuelve la llave privada al CPU principal.

Esto significa que aunque te roben el teléfono y desuelden la memoria, no pueden leer tus claves sin el chip Enclave específico.


---

## Ingeniería Inversa: Decompilando tu App

Piensas que tu código está seguro porque "compilaste" el APK.
Falso.

### Herramientas del Hacker
1.  **APKTool:** Desempaqueta el APK. Convierte los binarios `.dex` a código legible **Smali** (un ensamblador de Java).
2.  **JADX-GUI:** Convierte el `.dex` directamente a código Java casi perfecto. Puedo ver tu `if (password == "1234")`.
3.  **Python Decompilers:** Si usas Python empotrado, tus scripts `.pyc` se pueden revertir a `.py` con `uncompyle6`.

**¿Cómo protegerse?**
*   **Ofuscación (ProGuard/R8):** Renombra tus clases y variables a `a.b.c()`. Hace el código ilegible (pero la lógica sigue ahí).
*   **Compilación a C (Cython):** Convierte tu Python a binario nativo `.so`. Es mucho más difícil de aplicar ingeniería inversa (requiere IDA Pro/Ghidra y saber Assembler ARM).

---

## Autenticación Biométrica (Fingerprint/FaceID)

No guardes passwords. Usa Biometría.

### El Bóveda Segura (Keystore/Keychain)
Android y iOS tienen chips de seguridad dedicados (Secure Enclave / Titan M).
Son computadoras independientes dentro del celular.
*   Tu App pide al OS: "Genera una llave RSA y guárdala en el chip".
*   El chip dice: "Ok, pero para usarla, el usuario debe poner su huella".

**Flujo de Login Biométrico:**
1.  Servidor envía un "Challenge" (texto aleatorio).
2.  App pide huella al usuario.
3.  Si la huella es válida, el Chip firma el Challenge con la llave privada (que NUNCA sale del chip).
4.  App envía la firma al servidor.
5.  Servidor valida con la llave pública. `Login OK`.

---

## Certificate Pinning (SSL Pinning)

HTTPS cifra el tráfico, pero ¿qué si un hacker instala un Certificado Root falso en el celular de la víctima (Ataque MitM)? El candadito verde seguirá apareciendo, pero el hacker lee todo.

**Pinning:**
Tu app dice: "Solo confío en el certificado cuyo Hash sea `AF45...`".
Si el celular intenta conectarse con otro certificado (aunque sea válido para el OS), la app corta la conexión.
*   **Riesgo:** Si tu certificado expira y olvidas actualizar la app, nadie entra.

---

## OWASP MASVS (Mobile App Security Verification Standard)

La biblia de la seguridad móvil. Niveles:
1.  **L1 (Estándar):** Encriptar datos locales, usar HTTPS, permisos mínimos. (Obligatorio para todas).
2.  **L2 (Defensa en Profundidad):** SSL Pinning, detección de Root/Jailbreak, Teclados custom, Ofuscación avanzada. (Para Apps Bancarias).

### Detección de Root
Si el usuario es Root, tiene acceso total a tu memoria RAM. Puede leer tus variables.
Las apps bancarias se niegan a correr en Root.
Google provee **Play Integrity API** para verificar si el dispositivo está íntegro o hackeado.

---

## Laboratorio 5.5: Encriptación Local con `cryptography`

Nunca guardes tokens en texto plano.
Usa `Fernet` (AES simétrico).

```python
from cryptography.fernet import Fernet
import os

# Generar clave (esto debería venir del Keystore del sistema, simulado aquí)
key = Fernet.generate_key() 
cipher = Fernet(key)

dato_secreto = "Token_Bancario_123"

# Encriptar
encrypted = cipher.encrypt(dato_secreto.encode())
print(f"Guardando en disco: {encrypted}")

# Desencriptar
decrypted = cipher.decrypt(encrypted).decode()
print(f"Leído: {decrypted}")
```
En una app real, la `key` no se genera cada vez, se recupera del Android Keystore usando librerías nativas.

---

## Análisis de Tráfico: Proxy Man-in-the-Middle

Para auditar tu propia app, configura un Proxy en tu PC (Charles Proxy o Burp Suite).
Configura el Wifi del celular para usar ese Proxy.
Instala el certificado de Charles en el celular.
Abre tu app.
**¿Ves el tráfico en texto plano?**
*   Si SÍ: Tu app es insegura.
*   Si solo ves HTTPS encriptado: Bien.
*   Si la conexión falla: ¡Excelente! Tienes Certificate Pinning activo.

---


---

## Matemáticas de la Criptografía Móvil (ECC vs RSA)

En móvil, RSA-2048 es seguro pero lento y consume batería.
La industria se movió a **Elliptic Curve Cryptography (ECC)**.
*   Una llave ECC de **256 bits** es tan segura como una RSA de **3072 bits**.
*   Claves más cortas = Menos uso de CPU = Más batería.
*   Usado en Bitcoin, HTTPS moderno (ECDSA) y WhatsApp.

**Concepto Básico:**
Se basa en la dificultad de encontrar el logaritmo discreto en una curva elíptica sobre un campo finito.
$y^2 = x^3 + ax + b$
Es "fácil" multiplicar un punto por un escalar, pero "imposible" dividir para recuperar el escalar original.

---

## Privacidad y Cumplimiento Legal (GDPR / CCPA / LFPDPPP)

Si tu app se usa en Europa (GDPR) o California (CCPA) o México (LFPDPPP), tienes obligaciones legales.
1.  **Derecho al Olvido:** El usuario debe tener un botón "Borrar mi cuenta" que realmente borre todo del servidor. Apple ahora exige esto para aprobar cualquier app con login.
2.  **Consentimiento Explícito:** No puedes trackear geoubicación sin que el usuario diga "Sí". Las casillas pre-marcadas son ilegales.
3.  **Data Minimization:** No recolectes datos que no necesitas. Si pides contactos "por si acaso", te pueden multar.

**Tracking Transparency (iOS):**
Desde iOS 14, debes pedir permiso para "Rastrear" al usuario a través de otras apps y webs (IDFA). El 90% de usuarios dice que NO. Esto mató el modelo de negocio de Facebook Ads.

---

## Zero Trust Architecture en Móvil

"Confía en nadie, verifica todo".
Antiguamente: "Si estás en la VPN corporativa, tienes acceso a todo".
Moderno (Zero Trust): "No me importa si estás en el WiFi de la oficina. Tu celular podría estar hackeado".

1.  **Continuous validation:** Validar token en cada request.
2.  **Device Health Check:** El servidor pregunta: "¿El dispositivo tiene Root? ¿Tiene el último parche de seguridad?". Si no, deniega el acceso a la nómina, aunque el password sea correcto.
3.  **Micro-segmentación:** El celular de Ventas no puede ver el servidor de Ingeniería.

---

## Ataques Específicos de Móvil

### Tapjacking (Overlay Attack)
Una app maliciosa (ej. "Linterna Gratis") dibuja una ventana transparente encima de tu App Bancaria.
Tú crees que tocas "Ver Saldo", pero el click pasa a través y toca "Confirmar Transferencia" en la app invisible de abajo.
**Defensa:** Android moderno bloquea overlays sobre apps seguras (`FLAG_SECURE`), pero versiones viejas son vulnerables.

### Clipboard Hijacking
Copias tu Password o Dirección de Criptomonedas.
Un malware monitorea el portapapeles y reemplaza la dirección destino por la suya milisegundos antes de que pegues.
**Defensa:** Android ahora muestra una notificación "App X pegó desde el portapapeles" para alertar al usuario.

---

## Laboratorio Final: Hardening de una App Flet

Lista de comprobación (Checklist) que debes aplicar antes de publicar:
- [ ] **Ofuscación:** ¿Está activo R8/ProGuard en el build de Android?
- [ ] **Debuggable:** ¿`android:debuggable="false"` en el Manifest?
- [ ] **Backup:** ¿`android:allowBackup="false"`? (Evita que copien tus datos privados via ADB).
- [ ] **HTTPS:** ¿`android:usesCleartextTraffic="false"`? (Bloquea HTTP plano).
- [ ] **Secrets:** ¿Borraste todas las API Keys del código fuente?
- [ ] **Logging:** ¿Quitaste todos los `print()` que muestran tokens en la consola?

Cumplir esto te pone por delante del 80% de los desarrolladores junior.

---


---

## Internals: Secure Enclave (iOS) y Titan M (Android)

La seguridad moderna no es software. Es hardware.
Los iPhones tienen un coprocesador llamado **Secure Enclave**.
*   Tiene su propia RAM encriptada.
*   Tiene su propio Kernel (SepOS).
*   El procesador principal (A16 Bionic) **NO PUEDE LEER** la memoria del Enclave.

Cuando usas FaceID o guardas un Password en Keychain:
1.  El CPU principal envía los bytes encriptados al Enclave.
2.  El Enclave los desencripta con una llave **física** fundida en el silicio (UID).
3.  Verifica el FaceID (que también vive en el Enclave).
4.  Devuelve "Acceso Concedido" o "Denegado", pero **NUNCA** devuelve la llave privada al CPU principal.

Esto significa que aunque te roben el teléfono y desuelden la memoria, no pueden leer tus claves sin el chip Enclave específico.

---

## Ingeniería Inversa: Decompilando tu App

Piensas que tu código está seguro porque "compilaste" el APK.
Falso.

### Herramientas del Hacker
1.  **APKTool:** Desempaqueta el APK. Convierte los binarios `.dex` a código legible **Smali** (un ensamblador de Java).
2.  **JADX-GUI:** Convierte el `.dex` directamente a código Java casi perfecto. Puedo ver tu `if (password == "1234")`.
3.  **Python Decompilers:** Si usas Python empotrado, tus scripts `.pyc` se pueden revertir a `.py` con `uncompyle6`.

**¿Cómo protegerse?**
*   **Ofuscación (ProGuard/R8):** Renombra tus clases y variables a `a.b.c()`. Hace el código ilegible (pero la lógica sigue ahí).
*   **Compilación a C (Cython):** Convierte tu Python a binario nativo `.so`. Es mucho más difícil de aplicar ingeniería inversa (requiere IDA Pro/Ghidra y saber Assembler ARM).

---

## Autenticación Biométrica (Fingerprint/FaceID)

No guardes passwords. Usa Biometría.

### El Bóveda Segura (Keystore/Keychain)
Android y iOS tienen chips de seguridad dedicados (Secure Enclave / Titan M).
Son computadoras independientes dentro del celular.
*   Tu App pide al OS: "Genera una llave RSA y guárdala en el chip".
*   El chip dice: "Ok, pero para usarla, el usuario debe poner su huella".

**Flujo de Login Biométrico:**
1.  Servidor envía un "Challenge" (texto aleatorio).
2.  App pide huella al usuario.
3.  Si la huella es válida, el Chip firma el Challenge con la llave privada (que NUNCA sale del chip).
4.  App envía la firma al servidor.
5.  Servidor valida con la llave pública. `Login OK`.


## Ofuscación Agresiva (R8 Full Mode)

R8 no solo renombra. Analiza tu grafo de llamadas.
*   **Vertical Class Merging:** Si la clase A hereda de B y nadie más usa B, mezcla ambas en una sola.
*   **Constant Propagation:** Si siempre llamas a `metodo(5)`, R8 borra el parámetro y pone un 5 hardcodeado dentro del método.

Esto hace que el código descompilado sea casi imposible de leer para un humano.

---

## SafetyNet / Play Integrity API

¿Cómo sabe el banco que tu celular es seguro?
La app pide el servidor de Google un "Attestation".
Google revisa:
1.  ¿El Bootloader está desbloqueado?
2.  ¿La partición de sistema está modificada?
3.  ¿Hay binarios de Root?
4.  ¿Es un emulador?

Devuelve un Payload firmado criptográficamente. Si fallas la integridad, el servidor del banco rechaza tus transacciones.

---

## Secure Enclave y TEE

**TEE (Trusted Execution Environment):**
Un sistema operativo paralelo y aislado que corre en el mismo procesador (ARM TrustZone).
Android (REE - Rich Execution Environment) no puede leer la memoria del TEE.
Aquí se guardan las huellas digitales y las llaves privadas de Cifrado.
Aunque tengas Root en Android, no tienes Root en el TEE.

---

## Certificate Pinning 2.0: Public Key Pinning

No pinnes el certificado (caduca cada año).
Pinnea el **Hash de la Llave Pública (SPKI)**.
La llave pública puede ser la misma aunque renueves el certificado.
Genera hashes de backup (Backup Pins) por si tu llave se compromete.

---

## Detección de Debuggers

Tu app puede saber si la están debugeando.
`android.os.Debug.isDebuggerConnected()`
También puedes checar el tiempo de ejecución.
`t1 = now(); funcion(); t2 = now();`
Si `t2 - t1` > 1 segundo (cuando debería ser 1ms), alguien pausó la ejecución con un breakpoint. ¡Crashea la app intencionalmente!

## Profundización Técnica: Seguridad Ofensiva en Android

En este capítulo, vamos a desglosar Seguridad Ofensiva en Android átomo por átomo.
La ingeniería de software moderna requiere un entendimiento profundo de estos conceptos.

### Concepto Clave: Reverse Engineering y Pentesting - Parte 1
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Reverse Engineering y Pentesting, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_1():
    # Implementación de Seguridad Ofensiva en Android variante 1
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 1:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Reverse Engineering y Pentesting - Parte 2
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Reverse Engineering y Pentesting, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_2():
    # Implementación de Seguridad Ofensiva en Android variante 2
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 2:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Reverse Engineering y Pentesting - Parte 3
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Reverse Engineering y Pentesting, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_3():
    # Implementación de Seguridad Ofensiva en Android variante 3
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 3:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Reverse Engineering y Pentesting - Parte 4
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Reverse Engineering y Pentesting, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_4():
    # Implementación de Seguridad Ofensiva en Android variante 4
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 4:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Reverse Engineering y Pentesting - Parte 5
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Reverse Engineering y Pentesting, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_5():
    # Implementación de Seguridad Ofensiva en Android variante 5
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 5:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Reverse Engineering y Pentesting - Parte 6
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Reverse Engineering y Pentesting, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_6():
    # Implementación de Seguridad Ofensiva en Android variante 6
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 6:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Reverse Engineering y Pentesting - Parte 7
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Reverse Engineering y Pentesting, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_7():
    # Implementación de Seguridad Ofensiva en Android variante 7
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 7:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Reverse Engineering y Pentesting - Parte 8
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Reverse Engineering y Pentesting, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_8():
    # Implementación de Seguridad Ofensiva en Android variante 8
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 8:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Reverse Engineering y Pentesting - Parte 9
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Reverse Engineering y Pentesting, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_9():
    # Implementación de Seguridad Ofensiva en Android variante 9
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 9:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Reverse Engineering y Pentesting - Parte 10
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Reverse Engineering y Pentesting, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_10():
    # Implementación de Seguridad Ofensiva en Android variante 10
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 10:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Reverse Engineering y Pentesting - Parte 11
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Reverse Engineering y Pentesting, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_11():
    # Implementación de Seguridad Ofensiva en Android variante 11
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 11:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Reverse Engineering y Pentesting - Parte 12
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Reverse Engineering y Pentesting, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_12():
    # Implementación de Seguridad Ofensiva en Android variante 12
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 12:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Reverse Engineering y Pentesting - Parte 13
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Reverse Engineering y Pentesting, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_13():
    # Implementación de Seguridad Ofensiva en Android variante 13
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 13:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Reverse Engineering y Pentesting - Parte 14
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Reverse Engineering y Pentesting, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_14():
    # Implementación de Seguridad Ofensiva en Android variante 14
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 14:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Reverse Engineering y Pentesting - Parte 15
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Reverse Engineering y Pentesting, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_15():
    # Implementación de Seguridad Ofensiva en Android variante 15
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 15:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.




---

## OWASP Mobile Top 10 (Continuación)

Ya vimos los riesgos principales. Aquí los más sutiles pero peligrosos:

*   **M8: Manipulación de Código:** Un atacante toma tu app, le inyecta publicidad o malware, y la re-sube a tiendas piratas.
*   **M9: Ingeniería Inversa:** El atacante entiende tu algoritmo de negocio (ej. cómo calculas precios) y lo copia o lo explota.
*   **M10: Funcionalidad Extraña:** Permisos que no necesitas. Si tu app de Linterna pide permiso de "Contactos", es malware.

---

## Privacidad y Regulaciones (GDPR / LFPDPPP)

En móvil, recolectas datos sensibles (GPS, Salud).
*   **Consentimiento Explícito:** El usuario debe aceptar antes de que captures el primer dato.
*   **Derecho al Olvido:** Debes tener un botón de "Eliminar mi cuenta y todos mis datos".
*   **Cifrado en Transito:** No solo HTTPS, sino evitar "Leaks" en los Logs del sistema (Logcat). Nunca imprimas tokens en la consola.

---

## Profundización Técnica: Seguridad en dispositivos móviles

Para el ingeniero senior, Seguridad en dispositivos móviles no es magia. Es ciencia.

### Concepto 1: Seguridad Móvil
Este mecanismo es vital para la estabilidad del sistema.
```python
# Ejemplo técnico para concepto 1
def implementacion_referencia():
    # Lógica de bajo nivel
    pass
```
**Impacto:** Mejora la latencia en un 5%.

### Concepto 2: Seguridad Móvil
Este mecanismo es vital para la estabilidad del sistema.
```python
# Ejemplo técnico para concepto 2
def implementacion_referencia():
    # Lógica de bajo nivel
    pass
```
**Impacto:** Mejora la latencia en un 10%.

### Concepto 3: Seguridad Móvil
Este mecanismo es vital para la estabilidad del sistema.
```python
# Ejemplo técnico para concepto 3
def implementacion_referencia():
    # Lógica de bajo nivel
    pass
```
**Impacto:** Mejora la latencia en un 15%.

### Concepto 4: Seguridad Móvil
Este mecanismo es vital para la estabilidad del sistema.
```python
# Ejemplo técnico para concepto 4
def implementacion_referencia():
    # Lógica de bajo nivel
    pass
```
**Impacto:** Mejora la latencia en un 20%.

### Concepto 5: Seguridad Móvil
Este mecanismo es vital para la estabilidad del sistema.
```python
# Ejemplo técnico para concepto 5
def implementacion_referencia():
    # Lógica de bajo nivel
    pass
```
**Impacto:** Mejora la latencia en un 25%.

### Concepto 6: Seguridad Móvil
Este mecanismo es vital para la estabilidad del sistema.
```python
# Ejemplo técnico para concepto 6
def implementacion_referencia():
    # Lógica de bajo nivel
    pass
```
**Impacto:** Mejora la latencia en un 30%.

### Concepto 7: Seguridad Móvil
Este mecanismo es vital para la estabilidad del sistema.
```python
# Ejemplo técnico para concepto 7
def implementacion_referencia():
    # Lógica de bajo nivel
    pass
```
**Impacto:** Mejora la latencia en un 35%.

### Concepto 8: Seguridad Móvil
Este mecanismo es vital para la estabilidad del sistema.
```python
# Ejemplo técnico para concepto 8
def implementacion_referencia():
    # Lógica de bajo nivel
    pass
```
**Impacto:** Mejora la latencia en un 40%.

### Concepto 9: Seguridad Móvil
Este mecanismo es vital para la estabilidad del sistema.
```python
# Ejemplo técnico para concepto 9
def implementacion_referencia():
    # Lógica de bajo nivel
    pass
```
**Impacto:** Mejora la latencia en un 45%.

### Concepto 10: Seguridad Móvil
Este mecanismo es vital para la estabilidad del sistema.
```python
# Ejemplo técnico para concepto 10
def implementacion_referencia():
    # Lógica de bajo nivel
    pass
```
**Impacto:** Mejora la latencia en un 50%.

---

<div align="center">

[⬅️ Anterior: 5.4 Desarrollo con Flet](5.4.md) &nbsp;&nbsp;|&nbsp;&nbsp; [Menú Principal](../README.md) &nbsp;&nbsp;|&nbsp;&nbsp; [Volver al Inicio](../README.md)
</div>
