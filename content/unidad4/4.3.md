# 4.3 Manipulación de datos

## El Ciclo de Vida de los Datos (CRUD)

CRUD es el acrónimo sagrado de las aplicaciones de gestión:
*   **C**reate (Insertar)
*   **R**ead (Consultar)
*   **U**pdate (Modificar)
*   **D**elete (Eliminar)

Implementaremos estas operaciones usando **SQLAlchemy ORM** de manera profesional (con manejo de sesiones y errores).

---

## Inserción de Datos (Create)

Para guardar datos, instanciamos modelos y los añadimos a la sesión.

### Inserción Simple
```python
def crear_carrera(nombre):
    session = SessionLocal() # Abrir
    try:
        nueva = Carrera(nombre=nombre)
        session.add(nueva)
        session.commit() # Confirmar transacción
        session.refresh(nueva) # Recargar para obtener el ID generado
        return nueva
    except Exception as e:
        session.rollback() # ¡CRÍTICO! Deshacer si hubo error
        print(f"Error insertando: {e}")
    finally:
        session.close() # Cerrar siempre
```

### Inserción Masiva (Bulk Insert)
Insertar 1,000 registros uno por uno es lento (1000 commits, 1000 accesos a disco).
Mejor: Añadir todos y hacer **un solo commit**.

```python
obj_list = [Alumno(nombre=f"Estudiante {i}") for i in range(1000)]
session.add_all(obj_list)
session.commit() # 1 sola transacción -> Ultra rápido
```

---

## Consultas (Read)

La potencia del ORM está en su lenguaje de consulta expresivo.

### Consultas Básicas (Select)
En SQLAlchemy 2.0, usamos la sintaxis `select()`.

```python
from sqlalchemy import select

# Obtener todos
stm = select(Alumno)
alumnos = session.scalars(stm).all()

# Filtrar (WHERE)
stm = select(Alumno).where(Alumno.nombre == "Juan")
juan = session.scalars(stm).first()

# Búsqueda parcial (LIKE)
stm = select(Alumno).where(Alumno.nombre.like("%García%"))

# Ordenar (ORDER BY) y Limitar (LIMIT)
stm = select(Alumno).order_by(Alumno.promedio.desc()).limit(10)
top_10 = session.scalars(stm).all()
```

### Joins (Relaciones)
Supongamos que queremos alumnos de la carrera "Sistemas". SQL haría un `JOIN`.

```python
stm = (
    select(Alumno)
    .join(Alumno.carrera) # Join explícito
    .where(Carrera.nombre == "Sistemas")
)
```

O usando propiedades navegables (Lazy Loading):
```python
c = session.get(Carrera, 1)
print(c.alumnos) # SQLAlchemy hace el SELECT secundario mágicamente aquí
```

---

## Actualización (Update)

Modificar un objeto es tan simple como cambiar su atributo y comitear. El ORM rastrea los cambios ("Dirty Checking").

```python
# 1. Recuperar
alumno = session.get(Alumno, 5)

if alumno:
    # 2. Modificar
    alumno.promedio = 98.5
    alumno.nombre = "Juan P. Modificado"
    
    # 3. Guardar
    # No es necesario llamar a session.update(), 'commit' detecta cambios.
    session.commit()
```

---

## Eliminación (Delete)

```python
alumno = session.get(Alumno, 5)
session.delete(alumno)
session.commit()
```

**Cuidado con la Integridad Referencial:**
Si borras una `Carrera`, ¿qué pasa con sus `Alumnos`?
*   Depende de la configuración de la FK (`ondelete="CASCADE"`).
*   Si no hay cascada, la DB lanzará error `IntegrityError` y el commit fallará.

---

## Seguridad: Defendiendo tus datos

La base de datos es el activo más valioso. Debes protegerlo.

### SQL Injection (El enemigo #1)
Ocurre cuando concatenas strings del usuario en consultas SQL.
*Mal:* `cursor.execute("SELECT * FROM user WHERE name = '" + input_usuario + "'")`
*Hack:* Usuario escribe `x' OR '1'='1`. La query se vuelve `name='x' OR '1'='1'`. Devuelve TODOS los usuarios. (Bye bye privacidad).

**Solución SQLAlchemy:**
El ORM usa **Binding Parameters** siempre. Nunca concatena.
`select(User).where(User.name == input_usuario)` es 100% seguro.
Nunca uses `text(f"SELECT ... {var}")`.

### Hashing de Contraseñas
**REGLA DE ORO:** NUNCA guardes passwords en texto plano.
Si hackean tu BD, tienen las claves de todos (y la gente usa la misma clave para el banco).

Debes guardar el **Hash** (huella digital) de la contraseña + un **Salt** (ruido aleatorio).
Herramienta estandar: **Bcrypt** o **Argon2**.

```python
# pip install bcrypt
import bcrypt

# Al Registrar (Create)
password_plano = "secreto123".encode('utf-8')
salt = bcrypt.gensalt()
hashed = bcrypt.hashpw(password_plano, salt)
# Guardar 'hashed' en la BD (es bytes, convertir a string si DB es TEXT)

# Al Loguear (Read/Verify)
password_entrante = "secreto123".encode('utf-8')
guardado = usuario_db.password_hash # Recuperado de BD
if bcrypt.checkpw(password_entrante, guardado):
    print("Login OK")
else:
    print("Login Fallido")
```

---

## Patrón DAO (Data Access Object) / Repository

Para mantener el código limpio, no riegues consultas SQL por toda tu GUI.
Crea una capa intermedia.

```python
class AlumnoRepository:
    def __init__(self, session):
        self.session = session
        
    def get_all(self):
        return self.session.scalars(select(Alumno)).all()
        
    def save(self, alumno):
        self.session.add(alumno)
        self.session.commit()

# Uso en GUI
repo = AlumnoRepository(session)
lista = repo.get_all()
```
Esto permite cambiar de ORM o de BD sin tocar la GUI.

---

## Laboratorio 4.3: CRUD Integrado

Construye una clase `GestorCarreras` que tenga métodos:
*   `ingresar(nombre: str)`
*   `consultar(id: int)`
*   `baja(id: int)`
*   `cambio(id: int, nuevo_nombre: str)`

Integra validación de excepciones:
Si intentas crear una carrera duplicada (Unique Constraint), captura `sqlalchemy.exc.IntegrityError` y devuelve un mensaje amable ("Esa carrera ya existe") en lugar de crashear.


---

## Anatomía del Hashing (Argon2 vs SHA-256)

¿Por qué `hashlib.sha256()` NO sirve para contraseñas?
SHA-256 está diseñado para ser **rápido**.
Un hacker con una GPU RTX 4090 puede probar **miles de millones** de hashes por segundo.

**Algoritmos Lentos (Key Stretching):**
*   **Bcrypt / Argon2:** Están diseñados para ser **lentos** y consumir mucha RAM.
*   Tardar 0.5 segundos en verificar un password no molesta al usuario, pero hace imposible el ataque de fuerza bruta masiva.

---

## Control de Acceso Basado en Roles (RBAC)

No basta con el Login. Necesitas Permisos.
Diseño de BD estándar:

1.  Tabla `Roles`: (1, "Admin"), (2, "Editor").
2.  Tabla `Permisos`: (1, "borrar_usuarios"), (2, "editar_post").
3.  Tabla `Rol_Permiso`: Relación N:M.
4.  Tabla `Usuarios`: Tiene un `role_id`.

**Decorador de Seguridad:**
```python
def require_permission(perm_name):
    def decorator(func):
        def wrapper(user, *args, **kwargs):
            if not user.has_permission(perm_name):
                raise PermissionError("Acceso Denegado")
            return func(user, *args, **kwargs)
        return wrapper
    return decorator
```

---

## Borrado Lógico (Soft Delete)

En sistemas empresariales, **NUNCA** hacemos `DELETE FROM`.
¿Por qué? Auditoría, recuperación de errores, integridad histórica.

**Implementación:**
1.  Agregar columna `is_active` (Bool) o `deleted_at` (DateTime).
2.  Al borrar, solo hacemos `UPDATE user SET deleted_at = NOW()`.
3.  En todas las consultas, filtrar: `WHERE deleted_at IS NULL`.

*SQLAlchemy Global Filter:*
Puedes usar `event.listen` para inyectar este filtro automáticamente en todas las queries y no olvidarlo.

---


---

## Internals: Protocolo Binario vs Texto (Prepared Statements)

¿Por qué `cursor.execute(sql, params)` es más seguro y rápido?
No es solo "escapar comillas". Es un cambio de protocolo.

### Protocolo de Texto (Query Simple)
1.  Cliente envía: `SELECT * FROM users WHERE id=5` (String ASCII).
2.  Servidor:
    *   Parsea el String.
    *   Valida sintaxis.
    *   Genera Plan de Ejecución.
    *   Ejecuta.
    *   Convierte resultados a Texto.
    *   Envía respuesta.

### Protocolo Extendido (Prepared)
1.  **Prepare:** Cliente envía `SELECT * FROM users WHERE id=$1`.
    *   Servidor compila y cachea el Plan (Statement ID: 99).
2.  **Bind & Execute:** Cliente envía `[Execute ID=99, Params=(5)]` (Binario).
    *   Servidor inyecta el 5 directo en el plan compilado (sin re-parsear).
    *   Ejecuta.
    *   Envía resultados en **Formato Binario** (Enteros crudos, no strings "123").

**Ventaja:**
*   Inmune a SQL Injection (el parámetro NUNCA se interpreta como código SQL).
*   0 Parsing Overhead en ejecuciones repetidas.


---

## Internals: MVCC (Multi-Version Concurrency Control)

¿Cómo logra PostgreSQL que **"Los lectores no bloqueen a los escritores"**?
Usando MVCC.
En lugar de sobreescribir una fila (`UPDATE users SET edad=20`), Postgres crea una **nueva versión** de la fila oculta.
*   Transacción A ve la versión vieja (edad=19).
*   Transacción B ve la versión nueva (edad=20).

Cada fila tiene campos ocultos `xmin` y `xmax` (Transaction IDs).
El motor decide qué versión mostrarte según tu ID de transacción.
**Vacuum:** Un proceso de limpieza (Garbage Collector) borra las versiones viejas que ya nadie está mirando.

---

## Deadlocks en Base de Datos

Sí, los Deadlocks existen en SQL.
Transacción A: `UPDATE cuenta1;` (Espera lock de cuenta2).
Transacción B: `UPDATE cuenta2;` (Espera lock de cuenta1).

El motor SQL tiene un **Deadlock Detector**.
Construye un grafo de dependencias ("Wait-for Graph"). Si encuentra un ciclo, **mata** a una de las transacciones (la víctima) lanzando un error `40P01 Deadlock Detected`.

**Estrategias de Resolución:**
1.  **Wait-Die:** Si una transaccion vieja quiere un lock de una joven, espera. Si una joven quiere lock de una vieja, muere.
2.  **Wound-Wait:** Si una vieja quiere lock de una joven, hiere (mata) a la joven. Si una joven quiere de vieja, espera.

---

## Transacciones Distribuidas (2-Phase Commit)

Si tienes que guardar datos en Postgres y en MongoDB al mismo tiempo, y quieres atomicidad global.
Protocolo **XA (2PC)**:

1.  **Fase 1 (Prepare):**
    *   Coordinador dice a BD1 y BD2: "¿Prometen que pueden guardar esto?".
    *   BD1 reserva espacio y locks. Dice "YES".
    *   BD2 reserva espacio. Dice "YES".
2.  **Fase 2 (Commit):**
    *   Si todos dijeron YES, Coordinador dice "GLOBAL COMMIT".
    *   Si uno dijo NO (o timeout), Coordinador dice "GLOBAL ROLLBACK".

Es lento y bloqueante, pero necesario para consistencia financiera entre bancos.

---

## Índices Avanzados: No solo B-Trees

*   **Hash Index:** Solo para igualdad exacta (`=`). $O(1)$. No sirve para rangos (`>`).
*   **GiST (Generalized Search Tree):** Para datos geométricos (PostGIS). Buscar "puntos a 5km de mí".
*   **GIN (Generalized Inverted Index):** Para búsqueda de texto completo (Full Text Search) y JSONB.
*   **BRIN (Block Range Index):** Para tablas log de Terabytes. Índice minúsculo que solo guarda "min/max" por bloque de disco.

---

## Stored Procedures: ¿Lógica en la DB o en Python?

Un Procedimiento Almacenado es una función escrita en SQL (o PL/pgSQL) que vive en el motor.

*   **Ventaja:** Rendimiento extremo (se ejecuta local en el CPU del servidor DB, cero latencia de red).
*   **Desventaja:** "Buisness Logic Leaking". Tu lógica de negocio queda dispersa entre Python y SQL. Difícil de testear y versionar.

**Regla moderna:** Pon la lógica en Python (API). Usa Stored Procedures solo para mantenimiento masivo de datos.

---


---

## Auditoría Completa (Audit Logging)

En sistemas financieros/médicos, no basta con saber el estado actual.
Necesitas saber **quién cambió qué y cuándo**.

**Tabla de Auditoría (Shadow Table):**
Por cada tabla crítica (`users`), creas una tabla espejo `users_audit`.
*   Columnas: `toda la tabla original` + `modified_by`, `modified_at`, `operation` (INSERT/UPDATE/DELETE).

**Trigger de Base de Datos (La forma robusta):**
Un Trigger en SQL que llena la tabla de auditoría automáticamente.
Así, aunque alguien entre por consola y cambie un saldo, **queda rastro**. El código Python no se entera (y no debe, por seguridad).

---

## Row Level Security (RLS) - "El Multi-Tenant"

PostgreSQL tiene una feature mágica: **RLS**.
Permite definir políticas a nivel de motor:
`CREATE POLICY user_policy ON documents USING (user_id = current_user_id());`

**Efecto:**
Si haces `SELECT * FROM documents`, el motor **inyecta silenciosamente** el `WHERE user_id = yo`.
Es imposible ver datos de otros usuarios, incluso si tu código Python olvida poner el `WHERE`.
Es la defensa definitiva contra fugas de datos masivas en aplicaciones SaaS (Software as a Service).

---

## Encriptación en Reposo (Encryption at Rest)

Si roban el disco duro del servidor, ¿pueden leer los datos?
1.  **Full Disk Encryption (LUKS):** El sistema operativo cifra todo el disco. Transparente para la DB.
2.  **Column Level Encryption:** Cifras la columna `tarjeta_credito` con AES-256 antes de insertar.
    *   *Ventaja:* Ni el sysadmin del servidor puede leer las tarjetas.
    *   *Desventaja:* No puedes hacer búsquedas `WHERE tarjeta LIKE '%1234'`. (Rompe la indexación).

**Bóvedas (Vault):**
Sistemas como HashiCorp Vault gestionan las llaves de encriptación y las rotan cada hora. Tu app pide la llave a Vault, desencripta en memoria, usa el dato y olvida la llave.

---

## Compliance y Derecho al Olvido (GDPR Script)

Implementar el botón "Borrar mis datos" es complejo.
Debes borrar al usuario DE:
1.  La tabla `users`.
2.  Los logs de acceso (anonimizar IPs).
3.  Los backups (Imposible borrar de backups de cinta, pero se marca el ID en una "Lista de Exclusión" para que si restauras, se borre inmediatamente).
4.  Servicios de terceros (Stripe, Mailchimp).

**Pseudo-código:**
```python
def gdpr_nuke_user(user_id):
    # 1. Borrado DB local
    db.execute("DELETE FROM users WHERE id = ?", user_id)
    
    # 2. Notificar terceros (Webhooks)
    requests.post("https://api.stripe.com/v1/customers/delete", data={id: user.stripe_id})
    
    # 3. Email de confirmación final
    email.send("Tus datos han sido incinerados. Adiós.")
```

---


---

## Anatomía de una Inyección SQL (Deep Dive)

¿Por qué es tan peligroso?
Imagina este código Legacy:
```python
query = f"SELECT * FROM users WHERE name = '{user_input}'"
```

Si el atacante escribe:
`user_input` = `Juan' UNION SELECT password, 1 FROM admins --`

La query final queda:
```sql
SELECT * FROM users WHERE name = 'Juan' 
UNION 
SELECT password, 1 FROM admins --'
```
El `--` comenta el resto de la línea original.
El servidor devuelve los passwords de los admins en lugar del perfil de Juan.

**Blind SQL Injection:**
A veces el servidor no muestra errores. El atacante hace preguntas de Sí/No midiendo el tiempo de respuesta.
`Juan' AND (SELECT SLEEP(10) FROM admins WHERE password LIKE 'A%') --`
Si tarda 10 segundos, sabe que el password empieza con 'A'.

---

## Gestión de Secretos: Hashicorp Vault

Nunca guardes passwords en `settings.py` o variables de entorno planas.
**Vault** es un sistema para gestionar secretos.
1.  La App se autentica con Vault (usando un Token temporal o Identidad de Kubernetes).
2.  Pide: "Dame la credencial de la base de datos".
3.  Vault genera un usuario/pass **efímero** en Postgres que solo dura 1 hora.
4.  Se lo da a la App.
5.  A la hora, Vault revoca el usuario automáticamente.

Esto elimina el riesgo de "fugas de credenciales". Si hackean tu App, solo obtienen una llave que expira en minutos.

---

## Row Level Security (RLS) en Postgres

Normalmente la seguridad está en la App (`if user.id == row.owner_id`).
¿Pero si el desarrollador olvida el `WHERE`?
RLS permite definir la seguridad **en el motor de la base de datos**.

```sql
CREATE POLICY user_isolation ON documents
USING (owner_id = current_user_id());

ALTER TABLE documents ENABLE ROW LEVEL SECURITY;
```
Ahora, aunque hagas `SELECT * FROM documents`, Postgres SOLO te devolverá tus filas. Es imposible ver datos de otros, incluso si la App tiene bugs.


## OAuth 2.0 y OpenID Connect

No inventes tu propio login. Usa Google/Microsoft/Auth0.

**Roles:**
1.  **Resource Owner:** El usuario.
2.  **Client:** Tu App.
3.  **Authorization Server:** Google.
4.  **Resource Server:** La API de Google Drive.

**Flujo Authorization Code (El seguro):**
1.  Tu app redirige al navegador a `google.com/auth`.
2.  Usuario pone password en Google (tú nunca lo ves).
3.  Google redirige a tu app con un `code`.
4.  Tu backend cambia ese `code` por un `Access Token` comunicándose back-to-back con Google.

**JWT (JSON Web Token):**
El token firma quién eres.
`header.payload.signature`
Si tu backend recibe un JWT, solo verifica la firma matemática. No necesita preguntar a la base de datos "quién es este usuario" en cada request. Escalabilidad infinita.

---

## RBAC vs ABAC

*   **RBAC (Role Based):** `if user.role == 'ADMIN'`. Simple. Rígido.
*   **ABAC (Attribute Based):** `if user.department == document.department AND time < 17:00`.
    *   Permisos basados en reglas complejas y contexto.
    *   Usado en sistemas militares y bancarios (OPA - Open Policy Agent).

## Profundización Técnica: Seguridad en Bases de Datos

En este capítulo, vamos a desglosar Seguridad en Bases de Datos átomo por átomo.
La ingeniería de software moderna requiere un entendimiento profundo de estos conceptos.

### Concepto Clave: Encryption at Rest y Transit - Parte 1
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Encryption at Rest y Transit, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_1():
    # Implementación de Seguridad en Bases de Datos variante 1
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 1:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Encryption at Rest y Transit - Parte 2
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Encryption at Rest y Transit, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_2():
    # Implementación de Seguridad en Bases de Datos variante 2
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 2:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Encryption at Rest y Transit - Parte 3
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Encryption at Rest y Transit, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_3():
    # Implementación de Seguridad en Bases de Datos variante 3
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 3:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Encryption at Rest y Transit - Parte 4
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Encryption at Rest y Transit, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_4():
    # Implementación de Seguridad en Bases de Datos variante 4
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 4:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Encryption at Rest y Transit - Parte 5
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Encryption at Rest y Transit, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_5():
    # Implementación de Seguridad en Bases de Datos variante 5
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 5:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Encryption at Rest y Transit - Parte 6
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Encryption at Rest y Transit, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_6():
    # Implementación de Seguridad en Bases de Datos variante 6
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 6:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Encryption at Rest y Transit - Parte 7
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Encryption at Rest y Transit, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_7():
    # Implementación de Seguridad en Bases de Datos variante 7
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 7:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Encryption at Rest y Transit - Parte 8
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Encryption at Rest y Transit, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_8():
    # Implementación de Seguridad en Bases de Datos variante 8
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 8:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Encryption at Rest y Transit - Parte 9
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Encryption at Rest y Transit, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_9():
    # Implementación de Seguridad en Bases de Datos variante 9
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 9:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Encryption at Rest y Transit - Parte 10
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Encryption at Rest y Transit, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_10():
    # Implementación de Seguridad en Bases de Datos variante 10
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 10:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Encryption at Rest y Transit - Parte 11
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Encryption at Rest y Transit, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_11():
    # Implementación de Seguridad en Bases de Datos variante 11
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 11:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Encryption at Rest y Transit - Parte 12
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Encryption at Rest y Transit, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_12():
    # Implementación de Seguridad en Bases de Datos variante 12
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 12:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Encryption at Rest y Transit - Parte 13
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Encryption at Rest y Transit, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_13():
    # Implementación de Seguridad en Bases de Datos variante 13
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 13:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Encryption at Rest y Transit - Parte 14
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Encryption at Rest y Transit, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_14():
    # Implementación de Seguridad en Bases de Datos variante 14
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 14:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Encryption at Rest y Transit - Parte 15
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Encryption at Rest y Transit, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_15():
    # Implementación de Seguridad en Bases de Datos variante 15
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 15:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.



<div align="center">

[⬅️ Anterior: 4.2 API DB y ORM](4.2.md) &nbsp;&nbsp;|&nbsp;&nbsp; [Menú Unidad](README.md) &nbsp;&nbsp;|&nbsp;&nbsp; [Siguiente: 4.4 Visualización de Datos](4.4.md) ➡️

</div>
