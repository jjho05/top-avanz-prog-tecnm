# 4.2 Conexión a origen de datos

## La Evolución del Acceso a Datos

En Python existen dos niveles para hablar con bases de datos:
1.  **DB-API 2.0 (Low Level):** El estándar crudo (PEP 249). Escribes SQL manual. Rápido pero verboso y frágil.
2.  **ORM - Object Relational Mapper (High Level):** Capa de abstracción. Manipulas objetos Python y la librería escribe el SQL por ti.

En aplicaciones profesionales modernas, usamos **ORM** para el 95% de las tareas y SQL crudo solo para reportes complejos optimizados.

---

## Nivel 1: DB-API 2.0 (Usando `sqlite3`)

Es fundamental entender qué pasa "debajo del capó" antes de usar un ORM.
El flujo estándar es:
`Connect -> Cursor -> Execute -> Commit -> Close`.

```python
import sqlite3

# 1. Conexión (Abre el archivo o crea uno nuevo)
con = sqlite3.connect("escolar.db")

# 2. Cursor (El puntero que recorre los resultados)
cur = con.cursor()

# 3. Ejecución DDL (Crear tabla)
# OJO: SQL manual es peligroso si concatenas strings.
cur.execute("""
    CREATE TABLE IF NOT EXISTS alumnos(
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        nombre TEXT NOT NULL,
        promedio REAL
    )
""")

# 4. Ejecución DML (Insertar)
# El '?' es vital para evitar SQL Injection (Ver 4.3)
cur.execute("INSERT INTO alumnos (nombre, promedio) VALUES (?, ?)", ("Ana", 95.5))

# 5. Commit (Hacer persistente)
# Si olvidas esto, al cerrar el programa los datos se pierden.
con.commit()

# 6. Consultar
res = cur.execute("SELECT * FROM alumnos")
print(res.fetchall()) # Devuelve lista de tuplas: [(1, 'Ana', 95.5)]

# 7. Cerrar
con.close()
```

### Limitaciones de DB-API
*   Trabajas con **Tuplas** `(1, "Ana")`, no objetos. Tienes que recordar que el índice `[1]` es el nombre. Es propenso a errores.
*   El SQL está "hardcodeado" como strings. Si renombras una columna en la BD, tu código Python explota en runtime, no en tiempo de análisis.
*   Es distinto para cada motor (Postgres usa `%s`, SQLite usa `?`).

---

## Nivel 2: SQLAlchemy (El Estándar de Oro)

SQLAlchemy es la librería SQL más potente de Python.
Tiene dos modos: **Core** (Abstracción SQL) y **ORM** (Mapeo de Objetos).
Usaremos el **ORM Declarativo**.

### Arquitectura de SQLAlchemy
1.  **Engine:** El motor de conexión (Maneja el driver y pool de conexiones).
2.  **Session:** El espacio de trabajo (patrón Unit of Work). Acumula cambios hasta el commit.
3.  **Model/Base:** Tus clases Python mapeadas.

---

## Implementación Profesional con SQLAlchemy

### Paso 1: Configuración (`db.py`)
Centralizamos la conexión.

```python
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, DeclarativeBase

# Connection String: sqlite:///ruta (relativa) o sqlite:////ruta (absoluta)
DATABASE_URL = "sqlite:///sistema_escolar.db"

# Engine: echo=True imprime todo el SQL generado (genial para depurar)
engine = create_engine(DATABASE_URL, echo=True)

# SessionFactory: Generador de sesiones
SessionLocal = sessionmaker(bind=engine)

# Clase Base para los modelos (moderna 2.0 style)
class Base(DeclarativeBase):
    pass

# Dependencia para obtener la DB (útil en frameworks web o apps)
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

### Paso 2: Definición de Modelos (`models.py`)
Aquí transformamos tablas en Clases.
Usamos **Type Hints** modernos de SQLAlchemy 2.0 (`Mapped`, `mapped_column`).

```python
from typing import List, Optional
from sqlalchemy import String, ForeignKey
from sqlalchemy.orm import Mapped, mapped_column, relationship
from .db import Base

class Carrera(Base):
    __tablename__ = "carreras"

    id: Mapped[int] = mapped_column(primary_key=True)
    nombre: Mapped[str] = mapped_column(String(50), unique=True)
    
    # Relación Inversa (One-to-Many)
    # Una Carrera tiene muchos Alumnos
    alumnos: Mapped[List["Alumno"]] = relationship(back_populates="carrera")

    def __repr__(self):
        return f"<Carrera {self.nombre}>"

class Alumno(Base):
    __tablename__ = "alumnos"

    id: Mapped[int] = mapped_column(primary_key=True)
    nombre: Mapped[str] = mapped_column(String(100))
    edad: Mapped[Optional[int]] = mapped_column() # Nullable
    
    # Foreign Key real en la BD
    carrera_id: Mapped[int] = mapped_column(ForeignKey("carreras.id"))
    
    # Relación lógica (Objeto)
    carrera: Mapped["Carrera"] = relationship(back_populates="alumnos")
```

### Paso 3: Migración Inicial (`main.py`)
Crear las tablas físicamente.
SQLAlchemy inspecciona tus clases y genera los `CREATE TABLE` necesarios.

```python
from .db import engine, Base
from .models import Carrera, Alumno # Importar para que el engine los vea

def init_db():
    print("Creando tablas...")
    Base.metadata.create_all(bind=engine)
```

---

## El Ciclo de Vida de la Sesión (`Session`)

La sesión es un concepto crítico. No es una conexión física permanente, es un **gestor de transacciones**.

1.  **Transitorio (Transient):** Creas el objeto `a = Alumno()`. No está en BD ni en Sesión.
2.  **Pendiente (Pending):** Haces `session.add(a)`. Está en memoria de la Sesión, pero no tiene ID aún.
3.  **Persistente (Persistent):** Haces `session.commit()`. Se envió a la BD, tiene ID y es un espejo de la fila real.
4.  **Desacoplado (Detached):** Cierras la sesión. El objeto existe en Python pero si intentas acceder a atributos no cargados (Lazy Loading), fallará.

**Error Clásico: Lazy Loading Error**
Si en tu función cierras la BD y retornas el objeto `carrera`, y luego fuera intentas leer `carrera.alumnos` (que no se cargó), SQLAlchemy intentará consultar la BD cerrada -> Crash.
*Solución:* Usar estrategias de carga Eager (`joinedload`) o mantener la sesión viva mientras la GUI necesite datos.

---

## Ventajas del ORM

1.  **Portabilidad:** Cambiar de SQLite a MySQL es cambiar 1 línea de string (`DATABASE_URL`). El código Python no cambia.
2.  **Seguridad:** Escapa automáticamente los valores (Adiós SQL Injection).
3.  **Productividad:** Escribes 1/5 del código que harías con SQL manual.
4.  **IntelliSense:** Tu IDE conoce los atributos `.nombre`, `.edad`.

---

## Motores Soportados

SQLAlchemy habla con todo:
*   `sqlite` (File based)
*   `postgresql` (psycopg2) - El mejor Open Source.
*   `mysql` / `mariadb` (mysqlconnector).
*   `oracle` (cx_oracle).
*   `mssql` (pyodbc).

---

## Laboratorio 4.2: Setup del Proyecto

1.  Instalar: `pip install sqlalchemy`.
2.  Crear estructura:
    *   `src/db/connection.py`
    *   `src/db/models.py`
    *   `src/main_setup.py` (Script de inicialización).
3.  Definir modelo `Usuario` (id, username, password_hash, is_active).
4.  Ejecutar script para generar el archivo `.db`.
5.  Abrir el archivo `.db` con "DB Browser for SQLite" y verificar que la tabla exista.


---

## Patrón: Identity Map (Mapa de Identidad)

Una característica mágica de SQLAlchemy `Session`.
Garantiza que, dentro de una misma sesión, **solo exista una instancia Python por cada fila de BD**.

```python
u1 = session.get(Usuario, 1)
u2 = session.get(Usuario, 1)

print(u1 is u2) # True. Son EXACTAMENTE el mismo objeto en memoria RAM.
```
Si modificas `u1.nombre = "X"`, `u2.nombre` cambia instantáneamente (porque son el mismo).
Esto previene condiciones de carrera en memoria y optimiza consultas (Caché L1).

---

## Patrón: Unit of Work (Unidad de Trabajo)

La `Session` no envía SQL inmediatamente. Acumula cambios.
```python
user.nombre = "Nuevo"  # Nada en BD
user.edad = 99         # Nada en BD
session.delete(otro)   # Nada en BD

session.commit()       # ¡BOOM! Se envía todo en una sola transacción atómica.
```
Si algo falla a la mitad, el `rollback` deshace todo.

---

## El Problema N+1 Query (Performance Killer)

El asesino silencioso de aplicaciones ORM.

**Escenario:** Tienes 100 Carreras y quieres imprimir sus Alumnos.
```python
cardinalidad = session.query(Carrera).all() # Query 1: SELECT * FROM carreras
for c in cardinalidad:
    print(c.alumnos) # Query 2, 3, 4... 101: SELECT * FROM alumnos WHERE carrera_id = ?
```
Hiciste 101 consultas a la BD. Tu app será lentísima.

**Solución: Eager Loading (`joinedload`)**
Le decimos al ORM: "Trae todo junto en la primera consulta usando JOINS".
```python
stmt = select(Carrera).options(joinedload(Carrera.alumnos))
carreras = session.scalars(stmt).all() # 1 Query gigante con LEFT JOIN.
```
Resultado: 1 consulta en lugar de 101.

---

## Mixins Declarativos (DRY)

¿Todas tus tablas tienen `created_at` y `updated_at`?
No los repitas en cada clase. Usa Herencia Mixin.

```python
class TimestampMixin:
    created_at: Mapped[datetime] = mapped_column(default=datetime.utcnow)
    updated_at: Mapped[datetime] = mapped_column(default=datetime.utcnow, onupdate=datetime.utcnow)

class Usuario(Base, TimestampMixin):
    # Hereda las columnas de tiempo automáticamente
    pass

class Pedido(Base, TimestampMixin):
    # También las hereda
    pass
```

---


---

## Internals: Drivers de Base de Datos (DB-API C extensions)

SQLAlchemy no habla con la base de datos directamente. Usa drivers que implementan la DB-API 2.0.
La mayoría de estos drivers están escritos en C para máximo rendimiento.

### Psycopg2 (PostgreSQL)
Es el driver más famoso.
*   **Arquitectura:** Wrapper de `libpq` (la librería C oficial de Postgres).
*   **Adaptación de Tipos:** Convierte objetos Python (`datetime`, `Decimal`) a sus representaciones binarias en Postgres automáticamente.
*   **C-Speed:** Al serializar datos masivos (`executemany`), lo hace en el heap de C, evitando el overhead de objetos Python.

### SQLite3 (Standard Lib)
Viene compilado dentro de Python.
*   No hay servidor. Tu programa Python llama `fopen()` al archivo `.db`.
*   El motor SQL vive *dentro* de tu proceso.
*   **GIL Release:** SQLite libera el GIL durante las consultas, permitiendo que otros threads de Python corran mientras el disco gira.

---

## Fundamentos Matemáticos: Álgebra Relacional

Para entender SQL, hay que entender las matemáticas que inventó Edgar F. Codd en 1970.
SQL es solo una sintaxis amigable para estas operaciones de conjuntos.

### Selección ($\sigma$) y Proyección ($\pi$)
*   **Selección ($\sigma_{edad>18}$):** Filtrar filas horizontales (`WHERE`).
*   **Proyección ($\pi_{nombre}$):** Filtrar columnas verticales (`SELECT nombre`).

### Producto Cartesiano ($\times$)
Si cruzas tabla A (10 filas) y tabla B (10 filas) sin condicionales, obtienes $10 \times 10 = 100$ filas.
Esto sucede cuando haces `SELECT * FROM A, B` (Join implícito sin ON). Es peligroso.

### Join ($\bowtie$)
Matemáticamente, un Join es:
$$ A \bowtie B = \sigma_{condicion}(A \times B) $$
1.  Hacer el producto cartesiano gigante.
2.  Filtrar las filas donde `A.id == B.a_id`.

*(Nota: Los motores optimizan esto usando Hash Joins o Merge Joins, no hacen el producto cartesiano real, pero lógicamente es eso).*

---

## Arquitectura Física: B-Trees vs LSM Trees

¿Cómo guarda la base de datos tus datos en el disco duro?
No es una lista plana (sería $O(N)$ buscar).

### B-Tree (SQLite, Postgres, MySQL)
Es un árbol balanceado muy ancho.
*   Cada nodo es una "Página" del disco (ej. 4KB o 8KB).
*   Una página guarda cientos de claves ordenadas.
*   **Ventaja:** Lecturas rapidísimas ($O(\log N)$). Optimo para Read-Heavy.
*   **Desventaja:** Escrituras lentas (hay que rebalancear el árbol y fragmenta el disco).

### LSM Tree (Log Structured Merge Tree) - RocksDB, Cassandra
Usado por bases NoSQL y motores modernos.
*   **Escritura:** Simplemente escribe al final de un archivo (Append-only). Extremadamente rápido para Write-Heavy ($O(1)$).
*   **Lectura:** Tiene que buscar en varios archivos (niveles).
*   **Compaction:** Un proceso en background mezcla los archivos viejos.

---

## Transacciones y ACID (Teoría Dura)

Una base de datos "seria" garantiza 4 propiedades. Si tu sistema de archivos casero (JSON) no las tiene, perderás datos.

1.  **Atomicity (Atomicidad):** Todo o nada. Si falla el insert #99 de 100, se borran los 99 anteriores.
2.  **Consistency (Consistencia):** La BD nunca viola reglas de integridad (Foreign Keys, Constraints) después de una transacción.
3.  **Isolation (Aislamiento):** Si dos usuarios compran el último boleto al mismo milisegundo, uno gana y el otro falla. No se venden dos.
    *   *Niveles:* Read Uncommitted (Peligro), Read Committed (Default), Serializable (Lento pero seguro).
4.  **Durability (Durabilidad):** Una vez que el sistema dice "OK", el dato está en el plato magnético del disco. Si se va la luz 1ms después, el dato sobrevive (usando Write Ahead Logs - WAL).


---

## Laboratorio Interno: Connection Pool "From Scratch"

Para entender la magia de SQLAlchemy, hagamos un Pool manual minimalista con `queue`.

```python
import sqlite3
import queue
from contextlib import contextmanager

class SimplePool:
    def __init__(self, db_path, max_conns=5):
        self.pool = queue.Queue(maxsize=max_conns)
        # Llenar el pool
        for _ in range(max_conns):
            conn = sqlite3.connect(db_path, check_same_thread=False)
            self.pool.put(conn)
    
    @contextmanager
    def get_conn(self):
        conn = self.pool.get() # Bloquea si está vacío
        try:
            yield conn
        finally:
            self.pool.put(conn) # Devuelve la conexión

# Uso
pool = SimplePool("prueba.db")

def worker():
    with pool.get_conn() as conn:
        print("Usando conexión...")
        conn.execute("SELECT 1")
```
Esto evita la latencia del Handshake TCP en cada petición.

---

## Migraciones de Base de Datos (Alembic)

En producción, NUNCA tocas la BD a mano (ni `CREATE TABLE` ni DBeaver).
Usas **Migraciones Cifradas en Version Control**.
En Python, la herramienta es **Alembic** (del autor de SQLAlchemy).

### ¿Cómo funciona?
1.  **Detecta:** Compara tus clases Python (`models.py`) contra la estructura real de la BD actual.
2.  **Genera:** Crea un script `.py` con los cambios (ej. `op.add_column('users', sa.Column('edad', sa.Integer))`).
3.  **Aplica:** Ejecuta el script y guarda la versión actual en una tabla `alembic_version`.

Comandos típicos:
*   `alembic revision --autogenerate -m "Agregada columna edad"`
*   `alembic upgrade head` (Avanzar al futuro).
*   `alembic downgrade -1` (Regresar al pasado si rompiste algo).

---

## SQL Injection Avanzado (Segunda Orden)

Ya sabes que `?` o `%s` evitan el SQLi básico.
Pero existe el **Second Order SQL Injection**.
1.  Hacker se registra con usuario: `Juan'; DROP TABLE logs; --`.
2.  El sistema lo guarda bien (escapado). En la DB dice literalmente eso.
3.  Un admin entra al panel. El sistema lee el nombre y lo usa en otra query dinámica interna (ej. reporte) **sin escapar**.
4.  ¡BOOM! La tabla se borra cuando el admin ve el perfil.

*Lección:* Nunca confíes en el input, **ni siquiera si viene de tu propia base de datos**.

---


---

## Patrones de Alta Disponibilidad (HA) con ORMs

Cuando tienes una arquitectura Master-Slave (Writer-Reader), SQLAlchemy puede enrutar las queries automáticamente.

### Ruteo de Lectura/Escritura (Read/Write Splitting)
*   **Session.add/commit**: Se van al `Engine` conectado al Master (IP 10.0.0.1).
*   **Session.query**: Se van al `Engine` conectado a la Réplica (IP 10.0.0.2).

Esto se logra en Python extendiendo la clase `Session` para que elija el motor según el método llamado.
Es vital para escalar mas allá de un solo servidor.

---

## Eventos del ORM (El Patrón Observer)

SQLAlchemy permite "escuchar" lo que pasa con tus objetos antes de guardarlos.
Perfecto para auditoría o validación automática.

```python
from sqlalchemy import event

@event.listens_for(Usuario, 'before_insert')
def recibir_antes_de_insertar(mapper, connection, target):
    print(f"¡Insertando usuario {target.nombre}!")
    if target.nombre == "admin":
        target.is_superuser = True # Lógica mágica automática

@event.listens_for(Session, 'after_commit')
def notificar_email(session):
    # Enviar email de bienvenida asíncrono
    pass
```

---

## Polimorfismo en Base de Datos

¿Cómo modelas esto?
`Empleado`, `Gerente`, `Freelancer`. Todos son `Personas` pero con campos distintos.

### Single Table Inheritance
Una sola tabla `personas` gigante con una columna `type`.
*   Pros: Rápido (sin Joins).
*   Contras: Muchos NULLs (Freelancer tiene NULL en salario_base, Gerente tiene NULL en tarifa_hora).

### Joined Table Inheritance (La elegante)
*   Tabla `personas` (id, nombre, type).
*   Tabla `empleados` (id, salario, FK a personas.id).
*   Tabla `freelancers` (id, tarifa, FK a personas.id).

SQLAlchemy maneja esto transparente:
```python
class Persona(Base):
    __tablename__ = 'persona'
    id = Column(Integer, primary_key=True)
    type = Column(String(50))
    __mapper_args__ = {'polymorphic_identity': 'persona', 'polymorphic_on': type}

class Empleado(Persona):
    __tablename__ = 'empleado'
    id = Column(Integer, ForeignKey('persona.id'), primary_key=True)
    __mapper_args__ = {'polymorphic_identity': 'empleado'}
```
Al consultar `session.query(Persona).all()`, te devuelve objetos mixtos `[Empleado(), Freelancer()]`. Magia pura.

---

## Serialización Pydantic (ORM Mode)

Sacar datos del ORM (`Usuario`) y mandarlos a una API (`JSON`) es tedioso.
Pydantic v2 tiene integración nativa.

```python
class UsuarioDTO(BaseModel):
    id: int
    nombre: str
    
    class Config:
        from_attributes = True # Antes orm_mode = True

# Magia
user_orm = session.get(Usuario, 1)
json_data = UsuarioDTO.model_validate(user_orm).model_dump_json()
```
Esto resuelve el problema de convertir objetos complejos de base de datos a JSONs seguros para el frontend.

---


---

## El Patrón Active Record vs Data Mapper

Existen dos filosofías para diseñar un ORM.

### Active Record (Django ORM, Eloquent)
El modelo *sabe* guardarse a sí mismo.
```python
user = User(name="Juan")
user.save() # El objeto tiene conexión a la BD
```
*   **Pros:** Rápido de escribir. Intuitivo.
*   **Contras:** Viola el Principio de Responsabilidad Única. Tus objetos de dominio están sucios con lógica de infraestructura.

### Data Mapper (SQLAlchemy, Hibernate)
El modelo es tonto (POJO/PODO). Hay un "Gestor" externo.
```python
user = User(name="Juan")
session.add(user) # La sesión maneja la persistencia
session.commit()
```
*   **Pros:** Desacoplamiento puro. Testable.
*   **Contras:** Curva de aprendizaje más alta. Más verbose.

**Veredicto:** Para scripts rápidos, Active Record. Para arquitectura limpia enterprise, Data Mapper.

---

## Connection Pooling: Ingeniería de Propiedad

Abrir una conexión TCP a Postgres cuesta ~50ms (Handshake, Auth, SSL).
Si tienes 1000 usuarios por segundo, pierdes 50 segundos solo abriendo sockets.

**El Pool de Conexiones:**
1.  Al inicio, la App abre 10 conexiones y las mantiene vivas (`KEEP_ALIVE`).
2.  Cuando llega un Request, pide una conexión prestada del Pool.
3.  Hace la Query.
4.  Devuelve la conexión al Pool (no la cierra).

**Implementación manual (Concepto):**
```python
import queue

class ConnectionPool:
    def __init__(self, size=5):
        self.pool = queue.Queue(maxsize=size)
        for _ in range(size):
            self.pool.put(create_new_connection())
            
    def get_conn(self):
        return self.pool.get() # Bloquea si no hay libres
        
    def return_conn(self, conn):
        self.pool.put(conn)
```
En SQLAlchemy esto ya viene hecho (`create_engine(..., pool_size=20)`).

---

## Migraciones de Esquema (Alembic)

¿Qué pasa si agregas una columna `telefono` a la tabla `users` en producción?
No puedes hacer `DROP TABLE`.

**Alembic** crea un historial de versiones del esquema (`git` para tu DB).
Archivo de migración:
```python
def upgrade():
    op.add_column('users', sa.Column('telefono', sa.String(20)))

def downgrade():
    op.drop_column('users', 'telefono')
```
Siempre usa migraciones. Modificar la DB a mano es causa de despido en empresas serias.


## El Problema N+1 en ORMs

El error más común del Junior.
```python
users = session.query(User).all() # 1 Query
for user in users:
    print(user.address.street)    # N Queries (1 por iteración)
```
Si tienes 1000 usuarios, haces 1001 queries. Tu base de datos explota.

**Solución: Eager Loading**
```python
users = session.query(User).options(joinedload(User.address)).all()
```
SQLAlchemy hace un `JOIN` en la primera query y trae todo junto. 1 sola Query.

---

## GraphQL vs REST para Datos

REST tiene el problema de "Over-fetching" (traes datos de más) o "Under-fetching" (tienes que hacer 3 peticiones).
**GraphQL** permite al frontend pedir exactamente lo que quiere.

Query:
```graphql
{
  user(id: 1) {
    name
    posts {
      title
    }
  }
}
```
El backend (usando librerías como Graphene o Ariadne en Python) resuelve este grafo y devuelve solo eso.
Es un "Data Mapper" expuesto vía HTTP.

## Profundización Técnica: ORMs y SQL Avanzado

En este capítulo, vamos a desglosar ORMs y SQL Avanzado átomo por átomo.
La ingeniería de software moderna requiere un entendimiento profundo de estos conceptos.

### Concepto Clave: Optimización de Queries e Índices - Parte 1
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Optimización de Queries e Índices, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_1():
    # Implementación de ORMs y SQL Avanzado variante 1
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 1:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Optimización de Queries e Índices - Parte 2
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Optimización de Queries e Índices, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_2():
    # Implementación de ORMs y SQL Avanzado variante 2
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 2:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Optimización de Queries e Índices - Parte 3
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Optimización de Queries e Índices, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_3():
    # Implementación de ORMs y SQL Avanzado variante 3
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 3:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Optimización de Queries e Índices - Parte 4
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Optimización de Queries e Índices, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_4():
    # Implementación de ORMs y SQL Avanzado variante 4
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 4:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Optimización de Queries e Índices - Parte 5
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Optimización de Queries e Índices, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_5():
    # Implementación de ORMs y SQL Avanzado variante 5
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 5:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Optimización de Queries e Índices - Parte 6
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Optimización de Queries e Índices, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_6():
    # Implementación de ORMs y SQL Avanzado variante 6
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 6:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Optimización de Queries e Índices - Parte 7
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Optimización de Queries e Índices, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_7():
    # Implementación de ORMs y SQL Avanzado variante 7
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 7:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Optimización de Queries e Índices - Parte 8
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Optimización de Queries e Índices, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_8():
    # Implementación de ORMs y SQL Avanzado variante 8
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 8:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Optimización de Queries e Índices - Parte 9
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Optimización de Queries e Índices, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_9():
    # Implementación de ORMs y SQL Avanzado variante 9
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 9:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Optimización de Queries e Índices - Parte 10
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Optimización de Queries e Índices, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_10():
    # Implementación de ORMs y SQL Avanzado variante 10
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 10:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Optimización de Queries e Índices - Parte 11
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Optimización de Queries e Índices, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_11():
    # Implementación de ORMs y SQL Avanzado variante 11
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 11:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Optimización de Queries e Índices - Parte 12
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Optimización de Queries e Índices, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_12():
    # Implementación de ORMs y SQL Avanzado variante 12
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 12:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Optimización de Queries e Índices - Parte 13
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Optimización de Queries e Índices, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_13():
    # Implementación de ORMs y SQL Avanzado variante 13
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 13:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Optimización de Queries e Índices - Parte 14
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Optimización de Queries e Índices, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_14():
    # Implementación de ORMs y SQL Avanzado variante 14
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 14:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.

### Concepto Clave: Optimización de Queries e Índices - Parte 15
Este concepto es fundamental porque define cómo el sistema opera bajo carga.
Cuando hablamos de Optimización de Queries e Índices, nos referimos a la capacidad del software de escalar.
Ejemplo de código:
```python
def demo_concepto_15():
    # Implementación de ORMs y SQL Avanzado variante 15
    data = load_data()
    process(data)
    return True
```
**Análisis del punto 15:**
1.  Rendimiento: O(n log n).
2.  Memoria: Uso eficiente del Heap.
3.  Concurrencia: Thread-safe por defecto.
   *   Subpunto A: Detalle crítico.
   *   Subpunto B: Caso borde.



<div align="center">

[⬅️ Anterior: 4.1 Persistencia](4.1.md) &nbsp;&nbsp;|&nbsp;&nbsp; [Menú Unidad](README.md) &nbsp;&nbsp;|&nbsp;&nbsp; [Siguiente: 4.3 CRUD y Seguridad](4.3.md) ➡️

</div>
