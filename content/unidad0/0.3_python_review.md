# 0.3 Repaso acelerado de Python Avanzado

## 1. Más allá del "Hola Mundo"

Si vienes de un curso básico o intermedio, probablemente sepas declarar variables, hacer bucles `for` y crear funciones simples.
Para esta materia de **Tópicos Avanzados**, eso no es suficiente. Necesitas dominar las características idiomáticas que hacen a Python poderoso.

Escribir Python como si fuera C (bucles `for` con índices `i`, getters/setters manuales) se considera una mala práctica conocida como "Non-Pythonic Code".

Este módulo es una inmersión profunda a los conceptos necesarios para sobrevivir a las Unidades 1-5.

---

## 2. Estructuras de Datos Avanzadas

### 2.1 List Comprehensions (Comprensión de Listas)
Es la firma de identidad de Python. Permite transformar listas de forma declarativa (qué quiero) en lugar de imperativa (cómo lo hago).

**Estilo C (Imperativo):**
```python
numeros = [1, 2, 3, 4, 5]
cuadrados = []
for n in numeros:
    if n % 2 == 0:
        cuadrados.append(n ** 2)
# Resultado: [4, 16]
```

**Estilo Pythonico (Declarativo):**
```python
# [expresion for item in iterable if condicion]
cuadrados = [n ** 2 for n in numeros if n % 2 == 0]
```
*Ventaja:* Es más rápido (porque el bucle ocurre en C, no en Python) y más legible una vez te acostumbras.

### 2.2 Dictionary Comprehensions
Igual que las listas, pero para diccionarios.
```python
claves = ['a', 'b', 'c']
valores = [1, 2, 3]

# Crear dict {llave: valor}
mi_dict = {k: v for k, v in zip(claves, valores)}
# {'a': 1, 'b': 2, 'c': 3}
```
*Nota:* `zip` combina dos listas en paralelo.

### 2.3 Generadores y `yield`
Si tienes una lista de 1 millón de imágenes, `[img.process() for img in images]` cargará todas en RAM antes de empezar. Tu PC explotará.

Un **Generador** produce los valores uno por uno, bajo demanda (Lazy Evaluation).

```python
def procesador_masivo():
    for i in range(1000000):
        # ... lógica pesada ...
        yield i  # Pausa la función y entrega el valor

gen = procesador_masivo()
print(next(gen)) # 0
print(next(gen)) # 1
```
*Memoria usada:* Constante (mínima).
Las **Generator Expressions** usan paréntesis:
```python
gen_cuadrados = (n ** 2 for n in numeros) # No calcula nada aún.
```

---

## 3. Programación Orientada a Objetos (Moderna)

### 3.1 Clases, Self y Dunders
En Python todo es público por defecto. `self` es explícito.
Los métodos que empiezan y terminan con `__` son "Dunder Methods" (Double UNDERscore) o métodos mágicos.

```python
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    # Representación string para programadores (debugging)
    def __repr__(self):
        return f"Vector({self.x}, {self.y})"

    # Sobrecarga de operador +
    def __add__(self, otro):
        return Vector(self.x + otro.x, self.y + otro.y)

v1 = Vector(2, 4)
v2 = Vector(1, -1)
v3 = v1 + v2  # Llama a v1.__add__(v2)
print(v3)     # Vector(3, 3) -> Llama a __repr__
```

### 3.2 Dataclasses (Python 3.7+)
Escribir `__init__`, `__repr__`, `__eq__` manualmente es aburrido.
Las **Dataclasses** autogeneran todo ese código "boilerplate".

```python
from dataclasses import dataclass

@dataclass
class Producto:
    nombre: str
    precio: float
    stock: int = 0  # Valor por defecto

    def valor_total(self) -> float:
        return self.precio * self.stock

p = Producto("Laptop", 15000.0, 5)
print(p) 
# Producto(nombre='Laptop', precio=15000.0, stock=5)
# ¡Ya tiene __repr__ gratis!
```
*Uso en el curso:* Usaremos intensivamente Dataclasses para modelar datos de base de datos en la Unidad 4.

---

## 4. Decoradores (Decorators)

Un decorador es una función que "envuelve" a otra función para modificar su comportamiento sin tocar su código interno. Es el patrón de diseño "Decorator".

### Anatomía de un Decorador
```python
import functools
import time

def cronometro(func):
    """Mide cuánto tarda en ejecutarse una función."""
    @functools.wraps(func) # Preserva el nombre y docstring original
    def wrapper(*args, **kwargs):
        inicio = time.time()
        resultado = func(*args, **kwargs) # Ejecuta la original
        fin = time.time()
        print(f"{func.__name__} tardó {fin - inicio:.4f}s")
        return resultado
    return wrapper

@cronometro
def api_lenta():
    time.sleep(1)
    return "Datos"

api_lenta()
# Salida: api_lenta tardó 1.0012s
```
*Uso común:* Autenticación en servidores web (Flask/FastAPI), Logging, Cacheo.

---

## 5. Type Hinting (Tipado Estático)

Python es dinámico (`x` puede ser int y luego str), pero eso causa bugs en proyectos grandes.
Desde Python 3.5, podemos agregar "Pistas de Tipo". Python las ignora al ejecutar, pero VS Code (Pylance) las usa para encontrar errores.

```python
from typing import List, Optional, Dict

def procesar_usuarios(ids: List[int], activo: bool = True) -> Dict[str, int]:
    resultado = {}
    for i in ids:
        resultado[f"user_{i}"] = i * 10
    return resultado

# VS Code marcará error aquí antes de ejecutar:
# procesar_usuarios(["no", "soy", "int"]) 
```

### Tipos genéricos y Union
```python
def buscar(id: int | str) -> User | None: # Sintaxis moderna 3.10+
    # Acepta int O str. Retorna User O None.
    pass
```

---

## 6. Structural Pattern Matching (Python 3.10+)

El feature más grande en la historia reciente de Python. Es como un `switch-case` con esteroides.

```python
comando = ["move", 10, 20]

match comando:
    case ["quit"]:
        print("Saliendo...")
    case ["move", x, y]:
        print(f"Moviendo a coordenadas {x}, {y}")
        # x e y se asignan automáticamente (Unpacking)
    case ["attack", *enemigos]:
        print(f"Atacando a: {enemigos}")
    case _:
        print("Comando desconocido")
```

Esto no solo compara valores; **deconstruye la estructura** de los datos. Es ideal para procesar JSONs o eventos de GUI.

---

## 7. Manejo de Excepciones Profesional

Nunca uses `try: ... except: pass`. Eso oculta errores y hace el debugging imposible.

### Jerarquía de Excepciones
Captura solo lo que esperas.

```python
try:
    archivo = open("config.json")
    datos = json.load(archivo)
except FileNotFoundError:
    # Caso 1: No existe el archivo. Usamos default.
    datos = {}
except json.JSONDecodeError as e:
    # Caso 2: El archivo existe pero está corrupto. Es grave.
    logger.error(f"Config corrupta: {e}")
    raise # Relanzar para detener el programa
else:
    # Se ejecuta solo si NO hubo error
    print("Carga exitosa")
finally:
    # Se ejecuta SIEMPRE (limpieza)
    archivo.close() # (Aunque es mejor usar 'with open')
```

---

## 8. Context Managers (`with`)

Gestionan recursos (archivos, conexiones de red, locks) para asegurar que se cierren correctamente, incluso si hay errores.

```python
# Mal
f = open("log.txt", "w")
f.write("Hola")
# Si el programa falla aquí, el archivo queda abierto (bloqueado en Windows)
f.close()

# Bien
with open("log.txt", "w") as f:
    f.write("Hola")
# Al salir del bloque, f.close() se llama automáticamente.
```

Tú puedes crear tus propios Context Managers implementando `__enter__` y `__exit__`.

---

## 9. Funciones Lambda y Orden Superior

Las lambdas son funciones anónimas de una sola línea.
Útiles para `sort`, `filter`, `map` o callbacks de GUI.

```python
usuarios = [
    {"nombre": "Ana", "edad": 25},
    {"nombre": "Beto", "edad": 20},
]

# Ordenar por edad
usuarios.sort(key=lambda u: u["edad"])
```

---

## 10. `*args` y `**kwargs`

Permiten funciones con número variable de argumentos.
*   `*args` (Tupla): Argumentos posicionales extra.
*   `**kwargs` (Diccionario): Argumentos nombrados extra (Keyword Args).

```python
def configurar_ventana(titulo, **opciones):
    print(f"Creando ventana: {titulo}")
    if "color" in opciones:
        print(f"Pintando de {opciones['color']}")
    if "resize" in opciones:
        pass

configurar_ventana("Home", color="red", width=800, resize=False)
```

---

## Resumen del Capítulo

| Concepto | "Old School" Python | Modern Python 3.10+ |
| :--- | :--- | :--- |
| **Clases de Datos** | `class` con `__init__` largo | `@dataclass` |
| **Tipado** | Duck Typing puro | Type Hinting `List[str]` |
| **Control Flujo** | `if-elif-else` cadenas | `match-case` |
| **Strings** | `"%s" % var` o `.format()` | f-strings `f"{var}"` |
| **Funciones** | Imperativas | Funcionales (Comprehensions) |

Dominar estos conceptos es la barrera de entrada para la programación seria en Python.
Revisa los ejercicios en `/codigos/unidad0/repaso.py` para practicar.

<div align="center">

[⬅️ Anterior: 0.2 Entornos](0.2_virtual_envs.md) &nbsp;&nbsp;|&nbsp;&nbsp; [Menú Unidad](README.md) &nbsp;&nbsp;|&nbsp;&nbsp; [Siguiente: 0.4 Calidad](0.4_code_quality.md) ➡️

</div>
