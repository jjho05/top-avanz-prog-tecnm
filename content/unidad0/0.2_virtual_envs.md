# 0.2 Entornos Virtuales y Gestión de Dependencias

## 1. El Problema del "Infierno de Dependencias"

Para entender por qué los entornos virtuales son obligatorios (no opcionales) en Python, analicemos cómo Python gestiona las librerías.

### 1.1 Cómo funciona el `import` globalmente
Cuando instalas Python en tu computadora, existe una carpeta global llamada `site-packages`.
*   **Windows:** `C:\Python310\Lib\site-packages`
*   **Linux/Mac:** `/usr/local/lib/python3.10/site-packages`

Si ejecutas `pip install requests` en tu terminal global, la librería se descarga ahí.

### 1.2 El escenario del desastre
Imagina que eres un desarrollador profesional con dos proyectos:

**Proyecto A (Legacy - Creado en 2023):**
*   Usa `Django 3.2`.
*   Esta versión de Django requiere `asgiref==3.4`.

**Proyecto B (Nuevo - Creado en 2026):**
*   Usa `Django 5.0`.
*   Esta versión de Django requiere `asgiref==3.8`.

**El conflicto:**
Python solo puede tener **UNA** versión de una librería instalada en `site-packages`.
1.  Si instalas Django 5, pip actualizará `asgiref` a 3.8.
2.  De repente, el **Proyecto A** deja de funcionar porque `asgiref 3.8` introdujo cambios incompatibles (Breaking Changes) con Django 3.2.

Has roto un proyecto por trabajar en otro. Esto se llama **Dependency Hell**.
En lenguajes como Node.js (`node_modules`), cada carpeta de proyecto tiene sus librerías. En Python, por defecto, todo es global.

**La Solución:** Entornos Virtuales.

---

## 2. ¿Qué es un Entorno Virtual (Virtual Environment)?

Un entorno virtual es, esencialmente, **una carpeta** que engaña al intérprete de Python para que crea que es la única instalación en el sistema.

### Anatomía de un venv
Cuando creas un entorno virtual llamado `.venv`, se crea esta estructura:

```text
.venv/
├── bin/ (o Scripts/ en Windows)
│   ├── python     <-- Enlace simbólico al Python real del sistema
│   ├── pip        <-- El gestor de paquetes de ESTE entorno
│   └── activate   <-- Script para modificar el PATH
├── include/       <-- Cabeceras C
├── lib/
│   └── python3.10/
│       └── site-packages/  <-- ¡Aquí viven las librerías de este proyecto!
└── pyvenv.cfg     <-- Archivo de configuración que dice "home = /usr/bin"
```

Al "activar" el entorno, lo que haces es modificar temporalmente la variable de entorno `PATH` de tu terminal para que cuando escribas `python`, el sistema operativo encuentre `.venv/bin/python` antes que `/usr/bin/python`.

---

## 3. Herramientas de Gestión de Entornos

El ecosistema de Python ha evolucionado. Hay varias formas de hacer esto.

### 3.1 `venv` (Módulo Estándar)
*   **Pros:** Viene incluido en Python. Ligero. Estándar oficial.
*   **Contras:** Solo gestiona paquetes Python puro. No gestiona versiones de Python (no puedes crear un venv de Python 3.9 si tienes instalado el 3.10).
*   **Veredicto:** Usaremos este en el curso por ser el estándar fundamental.

### 3.2 `virtualenv` (El abuelo)
*   Predecesor de `venv`. Todavía se usa porque es un poco más rápido y tiene más features avanzados, pero `venv` lo ha reemplazado en el 99% de los casos.

### 3.3 `Conda` (Anaconda / Miniconda)
*   **Enfoque:** Ciencia de Datos y Machine Learning.
*   **Poder:** Puede instalar librerías **no-Python** (ej. binarios de C++, librerías de GPU CUDA, R, GDAL).
*   **Veredicto:** Indispensable para la Unidad 4 si trabajas con IA pesada. Para desarrollo web/app, es overkill.

### 3.4 `Poetry` / `Pipenv` (Gestores de Proyecto)
*   Son wrappers modernos. Manejan el venv y las dependencias a la vez.
*   Usan archivos `.lock` para garantizar determinismo absoluto.
*   **Veredicto:** Estándar en la industria profesional moderna.

---

## 4. Flujo de Trabajo Profesional con `venv`

Vamos a realizar el ciclo completo. Sigue estos pasos en tu terminal.

### Paso 1: Creación
Navega a la raíz de tu proyecto. El nombre estándar hoy en día es `.venv` (con punto, para que sea oculto).

```bash
# Windows
python -m venv .venv

# Mac/Linux
python3 -m venv .venv
```
*Nota: `python -m venv` significa "Ejecuta el módulo venv de la librería estándar".*

### Paso 2: Activación
Este es el paso que más confunde a los principiantes. Debes hacerlo **cada vez** que abres una nueva terminal.

```bash
# Windows (PowerShell)
.venv\Scripts\Activate.ps1
# Si da error de seguridad: Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser

# Windows (CMD)
.venv\Scripts\activate.bat

# Mac/Linux (Bash/Zsh)
source .venv/bin/activate
```

**¿Cómo sé si funcionó?**
Tu prompt debe cambiar. Verás `(.venv)` al principio.
`(.venv) usuario@laptop:~/proyecto $`

### Paso 3: Gestión de Paquetes (`pip`)
Ahora que estás dentro de la burbuja, puedes instalar cosas sin miedo.

```bash
# Siempre actualiza pip primero (el que viene preinstalado suele ser viejo)
pip install --upgrade pip

# Instalar librerías
pip install requests pandas customtkinter
```

**Comandos útiles de PIP:**
*   `pip list`: Muestra qué hay instalado en este entorno.
*   `pip show pandas`: Muestra detalles (versión, ubicación, dependencias).
*   `pip check`: Verifica si hay conflictos de dependencias rotas.
*   `pip cache purge`: Limpia la caché de descargas si tienes problemas de espacio.

---

## 5. Reproducibilidad: `requirements.txt`

Trabajaste 6 meses en tu proyecto. Todo funciona. Le pasas el código a tu profesor. Él intenta correrlo y falla. ¿Por qué? Porque él no tiene las librerías que tú instalaste.

No debes subir la carpeta `.venv` a Git (es gigante y específica de tu SO). Debes subir la **receta**.

### 5.1 Generar la receta (Freeze)
```bash
pip freeze > requirements.txt
```
Esto crea un archivo con versiones **exactas** (Pinning):
```text
certifi==2024.2.2
charset-normalizer==3.3.2
customtkinter==5.2.2
darkdetect==0.8.0
idna==3.6
numpy==1.26.4
packaging==24.0
pandas==2.2.1
python-dateutil==2.9.0.post0
pytz==2024.1
requests==2.31.0
six==1.16.0
tzdata==2024.1
urllib3==2.2.1
```
Observa cómo no solo guardó lo que instalaste (`pandas`), sino también sus sub-dependencias (`numpy`, `pytz`). Esto asegura que el entorno sea idéntico.

### 5.2 Instalar desde la receta
Cuando clones el repo en otra máquina:
1.  Creas el venv.
2.  Activas.
3.  Ejecutas:
```bash
pip install -r requirements.txt
```

### 5.3 Separación de Entornos (Dev vs Prod)
En proyectos grandes, tienes dependencias que solo usas tú (Linters, Tests) y no el servidor de producción.

Es común tener dos archivos:
*   `requirements.txt` (Para producción: solo lo necesario para correr la app).
*   `requirements-dev.txt` (Para desarrollo: incluye black, pylint, pytest).

Instalarías: `pip install -r requirements.txt -r requirements-dev.txt`.

---

## 6. Automatización Moderna: `pyproject.toml`

`pip` y `requirements.txt` son el estándar clásico. El futuro (y presente) es `pyproject.toml`.
Este archivo unifica la configuración de todas las herramientas (Black, Isort, Pytest) y las dependencias.

Para usar esto, se recomienda **Poetry**.

### Introducción rápida a Poetry (Opcional pero recomendado)
Si decides usar Poetry en lugar de venv+pip:

```bash
# Instalación global
pip install poetry

# Crear proyecto
poetry new mi-proyecto

# Agregar dependencias
poetry add pandas
poetry add --group dev black

# Correr un script
poetry run python main.py
```
Poetry gestiona el entorno virtual por ti (lo crea en una caché global) y resuelve conflictos de versiones con un algoritmo matemático avanzado.

---

## 7. Solución de Problemas Comunes

### A. "Execution of scripts is disabled on this system" (Windows)
PowerShell, por seguridad, bloquea la ejecución de scripts `.ps1`.
**Solución:** Abrir PowerShell como Administrador y correr:
`Set-ExecutionPolicy RemoteSigned` y aceptar.

### B. "pip" instala en el global aunque active el entorno
A veces, si tienes múltiples Pythons y el PATH mal configurado, el comando `pip` apunta al pip global.
**Solución robusta:**
Usa siempre `python -m pip`.
*   En vez de `pip install x`, usa `python -m pip install x`.
Esto garantiza que usas el pip asociado al intérprete de python activo.

### C. Conflicto de versiones (ResolutionImpossible)
El Paquete A pide `numpy<1.20`. El Paquete B pide `numpy>1.22`.
No hay solución matemática.
**Solución:**
1.  Busca versiones alternativas de A o B.
2.  Usa Docker para aislar las partes incompatibles del sistema.

### D. La carpeta `.venv` es gigante
Sí, puede pesar 100-500 MB.
**Solución:** Nunca la subas a Google Drive/Dropbox/OneDrive. Añádela a tus exclusiones de sincronización. Y por supuesto, añádela al `.gitignore`.

---

## 8. Laboratorio Práctico

1.  Abre la terminal en la carpeta `top-avanz-prog-tecnm`.
2.  Borra cualquier entorno `.venv` previo (`rm -rf .venv`).
3.  Crea uno nuevo: `python3 -m venv .venv`.
4.  Actívalo.
5.  Instala las dependencias del curso:
    `pip install customtkinter sqlalchemy flet matplotlib pandas requests`
6.  Verifica la integridad:
    `pip check`
    *(Debería decir "No broken requirements found").*
7.  Genera el requirements.txt:
    `pip freeze > requirements.txt`
8.  Inspecciona el archivo y observa cuántos paquetes se instalaron realmente.

<div align="center">

[⬅️ Anterior: 0.1 Entorno](0.1_python_env.md) &nbsp;&nbsp;|&nbsp;&nbsp; [Menú Unidad](README.md) &nbsp;&nbsp;|&nbsp;&nbsp; [Siguiente: 0.3 Repaso](0.3_python_review.md) ➡️

</div>
