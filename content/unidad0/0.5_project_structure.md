# 0.5 Estructura de Proyecto Profesional (Src Layout)

## 1. El mito del "Script Suelto"

Cuando aprendes, sueles tener un archivo `tarea.py`. A lo sumo tres: `main.py`, `funciones.py`, `datos.py`.
En el mundo real, los proyectos tienen 50, 500 o 5,000 archivos. Si los tiras todos en una carpeta:
1.  No sabrás qué es código y qué es configuración.
2.  Los imports serán una pesadilla (`from ...utils import x`).
3.  Los tests se mezclarán con el código productivo.
4.  Empaquetar la aplicación será imposible.

Existe un estándar de facto en la comunidad Python moderna: el **Src Layout** (Diseño de carpeta `src`).

---

## 2. Estructura Canónica

Así debe verse cualquier proyecto entregado en esta materia.

```text
mi-proyecto/
├── .git/                  <-- Metadatos de Git (Oculto)
├── .venv/                 <-- Entorno Virtual (Oculto, Ignorado)
├── .vscode/               <-- Configuración del Editor
├── data/                  <-- Archivos de datos (sqlite, json, csv, assets)
├── docs/                  <-- Documentación adicional
├── src/                   <-- CÓDIGO FUENTE REAL
│   └── mi_paquete/        <-- Nombre técnico del paquete (snake_case)
│       ├── __init__.py    <-- Marca la carpeta como paquete
│       ├── main.py        <-- Entry point interno
│       ├── config.py      <-- Configuraciones
│       ├── gui/           <-- Sub-paquete de Interfaz
│       │   ├── __init__.py
│       │   ├── windows.py
│       │   └── widgets.py
│       ├── db/            <-- Sub-paquete de Base de Datos
│       │   ├── __init__.py
│       │   └── models.py
│       └── utils/         <-- Utilidades genéricas
│           ├── __init__.py
│           └── helpers.py
├── tests/                 <-- Pruebas unitarias (espejo de src)
│   ├── __init__.py
│   ├── test_main.py
│   └── test_db.py
├── .gitignore             <-- Qué archvos ignora git
├── pyproject.toml         <-- Definición del proyecto y dependencias
├── README.md              <-- Portada del proyecto
└── requirements.txt       <-- (Opcional si usas pyproject)
```

---

## 3. ¿Por qué la carpeta `src`?

¿Por qué no poner `mi_paquete` directamente en la raíz?
Se hace para evitar el **"Import Parity Error"**.

Si tienes `mi_paquete` en la raíz, y haces `import mi_paquete` en tus tests, Python podría importar la carpeta local en lugar de la versión instalada en el environment. Esto causa bugs que solo aparecen en producción.
Al forzar el código a estar en `src/`, obligas a que el proyecto se instale (aunque sea en modo editable) para poder ser importado y testeado, simulando exactamente cómo funcionará cuando el usuario final lo instale.

---

## 4. Archivos de Raíz Esenciales

### 4.1 `.gitignore`
Es el portero. Dice qué archivos **NO** subir a GitHub.
Un `.gitignore` robusto para Python debe incluir:

```text
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# Virtual Environments
.env
.venv
env/
venv/

# IDE settings
.vscode/
.idea/

# Distribution / Packaging
dist/
build/
*.egg-info/

# Databases
*.db
*.sqlite3

# Logs
*.log
```
*Tip:* Usa [gitignore.io](https://www.toptal.com/developers/gitignore) y escribe "Python, Windows, macOS, VisualStudioCode".

### 4.2 `README.md`
Es la cara de tu proyecto. Debe responder:
1.  **¿Qué hace este proyecto?** (Resumen ejecutivo).
2.  **¿Cómo lo instalo?** (Pasos copy-pasteables).
3.  **¿Cómo lo uso?** (Ejemplo rápido).
4.  **Créditos y Licencia.**

### 4.3 `pyproject.toml`
Hablamos de él en 0.2 y 2.4. Es el archivo único de configuración.

```toml
[project]
name = "sistema-escolar"
version = "0.1.0"
dependencies = [
    "customtkinter",
    "sqlalchemy",
]

[tool.black]
line-length = 88

[tool.isort]
profile = "black"
```

---

## 5. Módulos y Paquetes (`__init__.py`)

### ¿Qué hace `__init__.py`?
1.  Le dice a Python: "Esta carpeta es un paquete importable".
2.  Se ejecuta inmediatamente al importar el paquete.

### El patrón "Facade"
Imagina que en `src/mi_paquete/db/models.py` tienes la clase `Usuario`.
La ruta de importación natural es:
`from src.mi_paquete.db.models import Usuario` (Muy largo y feo).

Si en `src/mi_paquete/__init__.py` pones:
```python
from .db.models import Usuario
```

Ahora puedes hacer:
`from src.mi_paquete import Usuario` (Limpio y profesional).

---

## 6. Layouts Específicos por Tipo de Proyecto

### A. Aplicación GUI (Tkinter/Flet)
Centraliza los "Assets" (imágenes, iconos).
```text
mi-gui/
├── assets/
│   ├── logo.png
│   └── theme.json
├── src/
│   └── app/
│       ├── ui/        <-- Vistas
│       └── logic/     <-- Controladores
```

### B. Aplicación Web (FastAPI/Django)
Sigue el patrón MVC o MVT.
```text
mi-web/
├── src/
│   ├── routers/       <-- Endpoints
│   ├── schemas/       <-- Pydantic Models
│   └── services/      <-- Lógica de Negocio
```

### C. Librería Publicable
Mínima y enfocada al `pyproject.toml`.

---

## 7. Práctica: Scaffolding (Andamiaje)

Crear esta estructura manualmente cada vez es tedioso.
En el ecosistema existen herramientas de "Scaffolding" como **Cookiecutter**.

```bash
# Instalar
pip install cookiecutter

# Usar una plantilla (Existen miles)
cookiecutter https://github.com/audreyfeldroy/cookiecutter-pypackage
```

Te hará preguntas: "¿Nombre del proyecto?", "¿Autor?", "¿Licencia?".
Y generará automáticamente toda la estructura de carpetas, el setup.py, los tests vacíos y el README.

### Para nuestra materia
No necesitamos Cookiecutter. Deberás crear tu estructura manualmente la primera vez para entenderla (en la Unidad 0), y luego puedes copiar y pegar esa carpeta base para las Unidades 1-5.

---

## 8. Gestión de Rutas (`pathlib` vs `os.path`)

Un problema clásico en estructuras complejas es encontrar archivos.
Si `main.py` quiere abrir `data/config.json`, no puedes hacer `open("../data/config.json")` porque los "puntos" dependen de **desde dónde ejecutas la terminal**, no de dónde está el archivo.

**Solución Profesional: Rutas Absolutas Dinámicas**
Usa `pathlib` + `__file__`.

```python
from pathlib import Path

# Obtener la ruta de ESTE archivo .py
BASE_DIR = Path(__file__).resolve().parent

# Navegar relativo a este archivo
ASSETS_DIR = BASE_DIR.parent / "assets"
LOGO_PATH = ASSETS_DIR / "logo.png"

# Esto funcionará siempre, sin importar desde dónde lances el script.
```

---

## 9. Resumen

Una buena estructura no hace que el código funcione mejor, pero hace que el programador trabaje mejor.
El **Src Layout**:
*   Aísla dependencias.
*   Facilita los tests.
*   Simplifica la colaboración en Git.
*   Es lo que separa un "script de estudiante" de una "aplicación de ingeniero".

<div align="center">

[⬅️ Anterior: 0.4 Calidad](0.4_code_quality.md) &nbsp;&nbsp;|&nbsp;&nbsp; [Menú Unidad](README.md) &nbsp;&nbsp;|&nbsp;&nbsp; [Ir a Unidad 1: GUI](../unidad1/1.1.md) ➡️

</div>
